/*
 * Generated by gdbus-codegen 2.34.1. DO NOT EDIT.
 *
 * The license of this code is the same as for the source it was derived from.
 */

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif

#include "goa-generated.h"

#include <string.h>
#ifdef G_OS_UNIX
#  include <gio/gunixfdlist.h>
#endif

typedef struct
{
  GDBusArgInfo parent_struct;
  gboolean use_gvariant;
} _ExtendedGDBusArgInfo;

typedef struct
{
  GDBusMethodInfo parent_struct;
  const gchar *signal_name;
  gboolean pass_fdlist;
} _ExtendedGDBusMethodInfo;

typedef struct
{
  GDBusSignalInfo parent_struct;
  const gchar *signal_name;
} _ExtendedGDBusSignalInfo;

typedef struct
{
  GDBusPropertyInfo parent_struct;
  const gchar *hyphen_name;
  gboolean use_gvariant;
} _ExtendedGDBusPropertyInfo;

typedef struct
{
  GDBusInterfaceInfo parent_struct;
  const gchar *hyphen_name;
} _ExtendedGDBusInterfaceInfo;

typedef struct
{
  const _ExtendedGDBusPropertyInfo *info;
  guint prop_id;
  GValue orig_value; /* the value before the change */
} ChangedProperty;

static void
_changed_property_free (ChangedProperty *data)
{
  g_value_unset (&data->orig_value);
  g_free (data);
}

static gboolean
_g_strv_equal0 (gchar **a, gchar **b)
{
  gboolean ret = FALSE;
  guint n;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  if (g_strv_length (a) != g_strv_length (b))
    goto out;
  for (n = 0; a[n] != NULL; n++)
    if (g_strcmp0 (a[n], b[n]) != 0)
      goto out;
  ret = TRUE;
out:
  return ret;
}

static gboolean
_g_variant_equal0 (GVariant *a, GVariant *b)
{
  gboolean ret = FALSE;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  ret = g_variant_equal (a, b);
out:
  return ret;
}

G_GNUC_UNUSED static gboolean
_g_value_equal (const GValue *a, const GValue *b)
{
  gboolean ret = FALSE;
  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
  switch (G_VALUE_TYPE (a))
    {
      case G_TYPE_BOOLEAN:
        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
        break;
      case G_TYPE_UCHAR:
        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
        break;
      case G_TYPE_INT:
        ret = (g_value_get_int (a) == g_value_get_int (b));
        break;
      case G_TYPE_UINT:
        ret = (g_value_get_uint (a) == g_value_get_uint (b));
        break;
      case G_TYPE_INT64:
        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
        break;
      case G_TYPE_UINT64:
        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
        break;
      case G_TYPE_DOUBLE:
        {
          /* Avoid -Wfloat-equal warnings by doing a direct bit compare */
          gdouble da = g_value_get_double (a);
          gdouble db = g_value_get_double (b);
          ret = memcmp (&da, &db, sizeof (gdouble)) == 0;
        }
        break;
      case G_TYPE_STRING:
        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
        break;
      case G_TYPE_VARIANT:
        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
        break;
      default:
        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
        else
          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
        break;
    }
  return ret;
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Account
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaAccount
 * @title: GoaAccount
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Account D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Account ---- */

static const _ExtendedGDBusMethodInfo _goa_account_method_info_remove =
{
  {
    -1,
    (gchar *) "Remove",
    NULL,
    NULL,
    NULL
  },
  "handle-remove",
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_account_method_info_ensure_credentials_OUT_ARG_expires_in =
{
  {
    -1,
    (gchar *) "expires_in",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _goa_account_method_info_ensure_credentials_OUT_ARG_pointers[] =
{
  &_goa_account_method_info_ensure_credentials_OUT_ARG_expires_in,
  NULL
};

static const _ExtendedGDBusMethodInfo _goa_account_method_info_ensure_credentials =
{
  {
    -1,
    (gchar *) "EnsureCredentials",
    NULL,
    (GDBusArgInfo **) &_goa_account_method_info_ensure_credentials_OUT_ARG_pointers,
    NULL
  },
  "handle-ensure-credentials",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _goa_account_method_info_pointers[] =
{
  &_goa_account_method_info_remove,
  &_goa_account_method_info_ensure_credentials,
  NULL
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_provider_type =
{
  {
    -1,
    (gchar *) "ProviderType",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "provider-type",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_provider_name =
{
  {
    -1,
    (gchar *) "ProviderName",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "provider-name",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_provider_icon =
{
  {
    -1,
    (gchar *) "ProviderIcon",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "provider-icon",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_id =
{
  {
    -1,
    (gchar *) "Id",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "id",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_is_temporary =
{
  {
    -1,
    (gchar *) "IsTemporary",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "is-temporary",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_attention_needed =
{
  {
    -1,
    (gchar *) "AttentionNeeded",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "attention-needed",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_identity =
{
  {
    -1,
    (gchar *) "Identity",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "identity",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_presentation_identity =
{
  {
    -1,
    (gchar *) "PresentationIdentity",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "presentation-identity",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_mail_disabled =
{
  {
    -1,
    (gchar *) "MailDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "mail-disabled",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_calendar_disabled =
{
  {
    -1,
    (gchar *) "CalendarDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "calendar-disabled",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_contacts_disabled =
{
  {
    -1,
    (gchar *) "ContactsDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "contacts-disabled",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_chat_disabled =
{
  {
    -1,
    (gchar *) "ChatDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "chat-disabled",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_documents_disabled =
{
  {
    -1,
    (gchar *) "DocumentsDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "documents-disabled",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_ticketing_disabled =
{
  {
    -1,
    (gchar *) "TicketingDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ticketing-disabled",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _goa_account_property_info_pointers[] =
{
  &_goa_account_property_info_provider_type,
  &_goa_account_property_info_provider_name,
  &_goa_account_property_info_provider_icon,
  &_goa_account_property_info_id,
  &_goa_account_property_info_is_temporary,
  &_goa_account_property_info_attention_needed,
  &_goa_account_property_info_identity,
  &_goa_account_property_info_presentation_identity,
  &_goa_account_property_info_mail_disabled,
  &_goa_account_property_info_calendar_disabled,
  &_goa_account_property_info_contacts_disabled,
  &_goa_account_property_info_chat_disabled,
  &_goa_account_property_info_documents_disabled,
  &_goa_account_property_info_ticketing_disabled,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_account_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Account",
    (GDBusMethodInfo **) &_goa_account_method_info_pointers,
    NULL,
    (GDBusPropertyInfo **) &_goa_account_property_info_pointers,
    NULL
  },
  "account",
};


/**
 * goa_account_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_account_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_account_interface_info.parent_struct;
}

/**
 * goa_account_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaAccount interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_account_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "provider-type");
  g_object_class_override_property (klass, property_id_begin++, "provider-name");
  g_object_class_override_property (klass, property_id_begin++, "provider-icon");
  g_object_class_override_property (klass, property_id_begin++, "id");
  g_object_class_override_property (klass, property_id_begin++, "is-temporary");
  g_object_class_override_property (klass, property_id_begin++, "attention-needed");
  g_object_class_override_property (klass, property_id_begin++, "identity");
  g_object_class_override_property (klass, property_id_begin++, "presentation-identity");
  g_object_class_override_property (klass, property_id_begin++, "mail-disabled");
  g_object_class_override_property (klass, property_id_begin++, "calendar-disabled");
  g_object_class_override_property (klass, property_id_begin++, "contacts-disabled");
  g_object_class_override_property (klass, property_id_begin++, "chat-disabled");
  g_object_class_override_property (klass, property_id_begin++, "documents-disabled");
  g_object_class_override_property (klass, property_id_begin++, "ticketing-disabled");
  return property_id_begin - 1;
}



/**
 * GoaAccount:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link>.
 */

/**
 * GoaAccountIface:
 * @parent_iface: The parent interface.
 * @handle_ensure_credentials: Handler for the #GoaAccount::handle-ensure-credentials signal.
 * @handle_remove: Handler for the #GoaAccount::handle-remove signal.
 * @get_attention_needed: Getter for the #GoaAccount:attention-needed property.
 * @get_calendar_disabled: Getter for the #GoaAccount:calendar-disabled property.
 * @get_chat_disabled: Getter for the #GoaAccount:chat-disabled property.
 * @get_contacts_disabled: Getter for the #GoaAccount:contacts-disabled property.
 * @get_documents_disabled: Getter for the #GoaAccount:documents-disabled property.
 * @get_id: Getter for the #GoaAccount:id property.
 * @get_identity: Getter for the #GoaAccount:identity property.
 * @get_is_temporary: Getter for the #GoaAccount:is-temporary property.
 * @get_mail_disabled: Getter for the #GoaAccount:mail-disabled property.
 * @get_presentation_identity: Getter for the #GoaAccount:presentation-identity property.
 * @get_provider_icon: Getter for the #GoaAccount:provider-icon property.
 * @get_provider_name: Getter for the #GoaAccount:provider-name property.
 * @get_provider_type: Getter for the #GoaAccount:provider-type property.
 * @get_ticketing_disabled: Getter for the #GoaAccount:ticketing-disabled property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link>.
 */

static void
goa_account_default_init (GoaAccountIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * GoaAccount::handle-remove:
   * @object: A #GoaAccount.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.Remove">Remove()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call goa_account_complete_remove() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-remove",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (GoaAccountIface, handle_remove),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * GoaAccount::handle-ensure-credentials:
   * @object: A #GoaAccount.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.EnsureCredentials">EnsureCredentials()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call goa_account_complete_ensure_credentials() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-ensure-credentials",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (GoaAccountIface, handle_ensure_credentials),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject properties for D-Bus properties: */
  /**
   * GoaAccount:provider-type:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderType">"ProviderType"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("provider-type", "ProviderType", "ProviderType", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:provider-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderName">"ProviderName"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("provider-name", "ProviderName", "ProviderName", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:provider-icon:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderIcon">"ProviderIcon"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("provider-icon", "ProviderIcon", "ProviderIcon", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:id:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Id">"Id"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("id", "Id", "Id", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:is-temporary:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.IsTemporary">"IsTemporary"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("is-temporary", "IsTemporary", "IsTemporary", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:attention-needed:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.AttentionNeeded">"AttentionNeeded"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("attention-needed", "AttentionNeeded", "AttentionNeeded", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:identity:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Identity">"Identity"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("identity", "Identity", "Identity", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:presentation-identity:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.PresentationIdentity">"PresentationIdentity"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("presentation-identity", "PresentationIdentity", "PresentationIdentity", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:mail-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.MailDisabled">"MailDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("mail-disabled", "MailDisabled", "MailDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:calendar-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.CalendarDisabled">"CalendarDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("calendar-disabled", "CalendarDisabled", "CalendarDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:contacts-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ContactsDisabled">"ContactsDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("contacts-disabled", "ContactsDisabled", "ContactsDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:chat-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ChatDisabled">"ChatDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("chat-disabled", "ChatDisabled", "ChatDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:documents-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.DocumentsDisabled">"DocumentsDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("documents-disabled", "DocumentsDisabled", "DocumentsDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:ticketing-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.TicketingDisabled">"TicketingDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("ticketing-disabled", "TicketingDisabled", "TicketingDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef GoaAccountIface GoaAccountInterface;
G_DEFINE_INTERFACE (GoaAccount, goa_account, G_TYPE_OBJECT);

/**
 * goa_account_get_provider_type: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderType">"ProviderType"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_account_dup_provider_type() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_account_get_provider_type (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_provider_type (object);
}

/**
 * goa_account_dup_provider_type: (skip)
 * @object: A #GoaAccount.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderType">"ProviderType"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_account_dup_provider_type (GoaAccount *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "provider-type", &value, NULL);
  return value;
}

/**
 * goa_account_set_provider_type: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderType">"ProviderType"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_account_set_provider_type (GoaAccount *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "provider-type", value, NULL);
}

/**
 * goa_account_get_provider_name: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderName">"ProviderName"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_account_dup_provider_name() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_account_get_provider_name (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_provider_name (object);
}

/**
 * goa_account_dup_provider_name: (skip)
 * @object: A #GoaAccount.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderName">"ProviderName"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_account_dup_provider_name (GoaAccount *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "provider-name", &value, NULL);
  return value;
}

/**
 * goa_account_set_provider_name: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderName">"ProviderName"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_account_set_provider_name (GoaAccount *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "provider-name", value, NULL);
}

/**
 * goa_account_get_provider_icon: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderIcon">"ProviderIcon"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_account_dup_provider_icon() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_account_get_provider_icon (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_provider_icon (object);
}

/**
 * goa_account_dup_provider_icon: (skip)
 * @object: A #GoaAccount.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderIcon">"ProviderIcon"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_account_dup_provider_icon (GoaAccount *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "provider-icon", &value, NULL);
  return value;
}

/**
 * goa_account_set_provider_icon: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderIcon">"ProviderIcon"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_account_set_provider_icon (GoaAccount *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "provider-icon", value, NULL);
}

/**
 * goa_account_get_id: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Id">"Id"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_account_dup_id() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_account_get_id (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_id (object);
}

/**
 * goa_account_dup_id: (skip)
 * @object: A #GoaAccount.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Id">"Id"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_account_dup_id (GoaAccount *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "id", &value, NULL);
  return value;
}

/**
 * goa_account_set_id: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Id">"Id"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_account_set_id (GoaAccount *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "id", value, NULL);
}

/**
 * goa_account_get_is_temporary: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.IsTemporary">"IsTemporary"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_account_get_is_temporary (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_is_temporary (object);
}

/**
 * goa_account_set_is_temporary: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.IsTemporary">"IsTemporary"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
goa_account_set_is_temporary (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "is-temporary", value, NULL);
}

/**
 * goa_account_get_attention_needed: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.AttentionNeeded">"AttentionNeeded"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_account_get_attention_needed (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_attention_needed (object);
}

/**
 * goa_account_set_attention_needed: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.AttentionNeeded">"AttentionNeeded"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_account_set_attention_needed (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "attention-needed", value, NULL);
}

/**
 * goa_account_get_identity: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Identity">"Identity"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_account_dup_identity() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_account_get_identity (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_identity (object);
}

/**
 * goa_account_dup_identity: (skip)
 * @object: A #GoaAccount.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Identity">"Identity"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_account_dup_identity (GoaAccount *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "identity", &value, NULL);
  return value;
}

/**
 * goa_account_set_identity: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Identity">"Identity"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_account_set_identity (GoaAccount *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "identity", value, NULL);
}

/**
 * goa_account_get_presentation_identity: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.PresentationIdentity">"PresentationIdentity"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_account_dup_presentation_identity() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_account_get_presentation_identity (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_presentation_identity (object);
}

/**
 * goa_account_dup_presentation_identity: (skip)
 * @object: A #GoaAccount.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.PresentationIdentity">"PresentationIdentity"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_account_dup_presentation_identity (GoaAccount *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "presentation-identity", &value, NULL);
  return value;
}

/**
 * goa_account_set_presentation_identity: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.PresentationIdentity">"PresentationIdentity"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_account_set_presentation_identity (GoaAccount *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "presentation-identity", value, NULL);
}

/**
 * goa_account_get_mail_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.MailDisabled">"MailDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_account_get_mail_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_mail_disabled (object);
}

/**
 * goa_account_set_mail_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.MailDisabled">"MailDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
goa_account_set_mail_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "mail-disabled", value, NULL);
}

/**
 * goa_account_get_calendar_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.CalendarDisabled">"CalendarDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_account_get_calendar_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_calendar_disabled (object);
}

/**
 * goa_account_set_calendar_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.CalendarDisabled">"CalendarDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
goa_account_set_calendar_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "calendar-disabled", value, NULL);
}

/**
 * goa_account_get_contacts_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ContactsDisabled">"ContactsDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_account_get_contacts_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_contacts_disabled (object);
}

/**
 * goa_account_set_contacts_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ContactsDisabled">"ContactsDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
goa_account_set_contacts_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "contacts-disabled", value, NULL);
}

/**
 * goa_account_get_chat_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ChatDisabled">"ChatDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_account_get_chat_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_chat_disabled (object);
}

/**
 * goa_account_set_chat_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ChatDisabled">"ChatDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
goa_account_set_chat_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "chat-disabled", value, NULL);
}

/**
 * goa_account_get_documents_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.DocumentsDisabled">"DocumentsDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_account_get_documents_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_documents_disabled (object);
}

/**
 * goa_account_set_documents_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.DocumentsDisabled">"DocumentsDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
goa_account_set_documents_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "documents-disabled", value, NULL);
}

/**
 * goa_account_get_ticketing_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.TicketingDisabled">"TicketingDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_account_get_ticketing_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_ticketing_disabled (object);
}

/**
 * goa_account_set_ticketing_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.TicketingDisabled">"TicketingDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
goa_account_set_ticketing_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "ticketing-disabled", value, NULL);
}

/**
 * goa_account_call_remove:
 * @proxy: A #GoaAccountProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.Remove">Remove()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_account_call_remove_finish() to get the result of the operation.
 *
 * See goa_account_call_remove_sync() for the synchronous, blocking version of this method.
 */
void
goa_account_call_remove (
    GoaAccount *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Remove",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * goa_account_call_remove_finish:
 * @proxy: A #GoaAccountProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_account_call_remove().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with goa_account_call_remove().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
goa_account_call_remove_finish (
    GoaAccount *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_account_call_remove_sync:
 * @proxy: A #GoaAccountProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.Remove">Remove()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See goa_account_call_remove() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
goa_account_call_remove_sync (
    GoaAccount *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Remove",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_account_call_ensure_credentials:
 * @proxy: A #GoaAccountProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.EnsureCredentials">EnsureCredentials()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_account_call_ensure_credentials_finish() to get the result of the operation.
 *
 * See goa_account_call_ensure_credentials_sync() for the synchronous, blocking version of this method.
 */
void
goa_account_call_ensure_credentials (
    GoaAccount *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "EnsureCredentials",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * goa_account_call_ensure_credentials_finish:
 * @proxy: A #GoaAccountProxy.
 * @out_expires_in: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_account_call_ensure_credentials().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with goa_account_call_ensure_credentials().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
goa_account_call_ensure_credentials_finish (
    GoaAccount *proxy,
    gint *out_expires_in,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_expires_in);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_account_call_ensure_credentials_sync:
 * @proxy: A #GoaAccountProxy.
 * @out_expires_in: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.EnsureCredentials">EnsureCredentials()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See goa_account_call_ensure_credentials() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
goa_account_call_ensure_credentials_sync (
    GoaAccount *proxy,
    gint *out_expires_in,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "EnsureCredentials",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_expires_in);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_account_complete_remove:
 * @object: A #GoaAccount.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.Remove">Remove()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
goa_account_complete_remove (
    GoaAccount *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * goa_account_complete_ensure_credentials:
 * @object: A #GoaAccount.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @expires_in: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.EnsureCredentials">EnsureCredentials()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
goa_account_complete_ensure_credentials (
    GoaAccount *object,
    GDBusMethodInvocation *invocation,
    gint expires_in)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(i)",
                   expires_in));
}

/* ------------------------------------------------------------------------ */

/**
 * GoaAccountProxy:
 *
 * The #GoaAccountProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaAccountProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaAccountProxy.
 */

struct _GoaAccountProxyPrivate
{
  GData *qdata;
};

static void goa_account_proxy_iface_init (GoaAccountIface *iface);

G_DEFINE_TYPE_WITH_CODE (GoaAccountProxy, goa_account_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_ACCOUNT, goa_account_proxy_iface_init));

static void
goa_account_proxy_finalize (GObject *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_account_proxy_parent_class)->finalize (object);
}

static void
goa_account_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 14);
  info = _goa_account_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
goa_account_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface org.gnome.OnlineAccounts.Account: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
goa_account_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 14);
  info = _goa_account_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.gnome.OnlineAccounts.Account", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) goa_account_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
goa_account_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_account_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_ACCOUNT);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_ACCOUNT);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_account_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_account_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_account_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
goa_account_proxy_get_provider_type (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ProviderType");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_account_proxy_get_provider_name (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ProviderName");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_account_proxy_get_provider_icon (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ProviderIcon");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_account_proxy_get_id (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Id");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_is_temporary (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "IsTemporary");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_attention_needed (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "AttentionNeeded");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_account_proxy_get_identity (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Identity");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_account_proxy_get_presentation_identity (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PresentationIdentity");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_mail_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "MailDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_calendar_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "CalendarDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_contacts_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ContactsDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_chat_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ChatDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_documents_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "DocumentsDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_ticketing_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "TicketingDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static void
goa_account_proxy_init (GoaAccountProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_ACCOUNT_PROXY, GoaAccountProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_account_interface_info ());
}

static void
goa_account_proxy_class_init (GoaAccountProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (GoaAccountProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_account_proxy_finalize;
  gobject_class->get_property = goa_account_proxy_get_property;
  gobject_class->set_property = goa_account_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_account_proxy_g_signal;
  proxy_class->g_properties_changed = goa_account_proxy_g_properties_changed;


  goa_account_override_properties (gobject_class, 1);
}

static void
goa_account_proxy_iface_init (GoaAccountIface *iface)
{
  iface->get_provider_type = goa_account_proxy_get_provider_type;
  iface->get_provider_name = goa_account_proxy_get_provider_name;
  iface->get_provider_icon = goa_account_proxy_get_provider_icon;
  iface->get_id = goa_account_proxy_get_id;
  iface->get_is_temporary = goa_account_proxy_get_is_temporary;
  iface->get_attention_needed = goa_account_proxy_get_attention_needed;
  iface->get_identity = goa_account_proxy_get_identity;
  iface->get_presentation_identity = goa_account_proxy_get_presentation_identity;
  iface->get_mail_disabled = goa_account_proxy_get_mail_disabled;
  iface->get_calendar_disabled = goa_account_proxy_get_calendar_disabled;
  iface->get_contacts_disabled = goa_account_proxy_get_contacts_disabled;
  iface->get_chat_disabled = goa_account_proxy_get_chat_disabled;
  iface->get_documents_disabled = goa_account_proxy_get_documents_disabled;
  iface->get_ticketing_disabled = goa_account_proxy_get_ticketing_disabled;
}

/**
 * goa_account_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_account_proxy_new_finish() to get the result of the operation.
 *
 * See goa_account_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_account_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_ACCOUNT_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Account", NULL);
}

/**
 * goa_account_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_account_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_account_proxy_new().
 *
 * Returns: (transfer full) (type GoaAccountProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaAccount *
goa_account_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_ACCOUNT (ret);
  else
    return NULL;
}

/**
 * goa_account_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_account_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaAccountProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaAccount *
goa_account_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_ACCOUNT_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Account", NULL);
  if (ret != NULL)
    return GOA_ACCOUNT (ret);
  else
    return NULL;
}


/**
 * goa_account_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_account_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_account_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_account_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_account_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_ACCOUNT_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Account", NULL);
}

/**
 * goa_account_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_account_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_account_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaAccountProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaAccount *
goa_account_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_ACCOUNT (ret);
  else
    return NULL;
}

/**
 * goa_account_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_account_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_account_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaAccountProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaAccount *
goa_account_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_ACCOUNT_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Account", NULL);
  if (ret != NULL)
    return GOA_ACCOUNT (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaAccountSkeleton:
 *
 * The #GoaAccountSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaAccountSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaAccountSkeleton.
 */

struct _GoaAccountSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_account_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_ACCOUNT);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_ACCOUNT);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_account_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_account_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_account_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_account_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_account_skeleton_vtable =
{
  _goa_account_skeleton_handle_method_call,
  _goa_account_skeleton_handle_get_property,
  _goa_account_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
goa_account_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return goa_account_interface_info ();
}

static GDBusInterfaceVTable *
goa_account_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_goa_account_skeleton_vtable;
}

static GVariant *
goa_account_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_account_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_account_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_account_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_account_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Account", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _goa_account_emit_changed (gpointer user_data);

static void
goa_account_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _goa_account_emit_changed (skeleton);
}

static void goa_account_skeleton_iface_init (GoaAccountIface *iface);
G_DEFINE_TYPE_WITH_CODE (GoaAccountSkeleton, goa_account_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_ACCOUNT, goa_account_skeleton_iface_init));

static void
goa_account_skeleton_finalize (GObject *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  guint n;
  for (n = 0; n < 14; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_account_skeleton_parent_class)->finalize (object);
}

static void
goa_account_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 14);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_goa_account_emit_changed (gpointer user_data)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.gnome.OnlineAccounts.Account",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_goa_account_schedule_emit_changed (GoaAccountSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
goa_account_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _goa_account_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
goa_account_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 14);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _goa_account_schedule_emit_changed (skeleton, _goa_account_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
goa_account_skeleton_init (GoaAccountSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_ACCOUNT_SKELETON, GoaAccountSkeletonPrivate);
  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 14);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[3], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[4], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[5], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[6], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[7], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[8], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[9], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[10], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[11], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[12], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[13], G_TYPE_BOOLEAN);
}

static const gchar *
goa_account_skeleton_get_provider_type (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_account_skeleton_get_provider_name (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_account_skeleton_get_provider_icon (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_account_skeleton_get_id (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[3]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_is_temporary (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[4]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_attention_needed (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[5]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_account_skeleton_get_identity (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[6]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_account_skeleton_get_presentation_identity (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[7]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_mail_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[8]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_calendar_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[9]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_contacts_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[10]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_chat_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[11]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_documents_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[12]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_ticketing_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[13]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
goa_account_skeleton_class_init (GoaAccountSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (GoaAccountSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_account_skeleton_finalize;
  gobject_class->get_property = goa_account_skeleton_get_property;
  gobject_class->set_property = goa_account_skeleton_set_property;
  gobject_class->notify       = goa_account_skeleton_notify;


  goa_account_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_account_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_account_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_account_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_account_skeleton_dbus_interface_get_vtable;
}

static void
goa_account_skeleton_iface_init (GoaAccountIface *iface)
{
  iface->get_provider_type = goa_account_skeleton_get_provider_type;
  iface->get_provider_name = goa_account_skeleton_get_provider_name;
  iface->get_provider_icon = goa_account_skeleton_get_provider_icon;
  iface->get_id = goa_account_skeleton_get_id;
  iface->get_is_temporary = goa_account_skeleton_get_is_temporary;
  iface->get_attention_needed = goa_account_skeleton_get_attention_needed;
  iface->get_identity = goa_account_skeleton_get_identity;
  iface->get_presentation_identity = goa_account_skeleton_get_presentation_identity;
  iface->get_mail_disabled = goa_account_skeleton_get_mail_disabled;
  iface->get_calendar_disabled = goa_account_skeleton_get_calendar_disabled;
  iface->get_contacts_disabled = goa_account_skeleton_get_contacts_disabled;
  iface->get_chat_disabled = goa_account_skeleton_get_chat_disabled;
  iface->get_documents_disabled = goa_account_skeleton_get_documents_disabled;
  iface->get_ticketing_disabled = goa_account_skeleton_get_ticketing_disabled;
}

/**
 * goa_account_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link>.
 *
 * Returns: (transfer full) (type GoaAccountSkeleton): The skeleton object.
 */
GoaAccount *
goa_account_skeleton_new (void)
{
  return GOA_ACCOUNT (g_object_new (GOA_TYPE_ACCOUNT_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.OAuth2Based
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaOAuth2Based
 * @title: GoaOAuth2Based
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.OAuth2Based D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.OAuth2Based ---- */

static const _ExtendedGDBusArgInfo _goa_oauth2_based_method_info_get_access_token_OUT_ARG_access_token =
{
  {
    -1,
    (gchar *) "access_token",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_oauth2_based_method_info_get_access_token_OUT_ARG_expires_in =
{
  {
    -1,
    (gchar *) "expires_in",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _goa_oauth2_based_method_info_get_access_token_OUT_ARG_pointers[] =
{
  &_goa_oauth2_based_method_info_get_access_token_OUT_ARG_access_token,
  &_goa_oauth2_based_method_info_get_access_token_OUT_ARG_expires_in,
  NULL
};

static const _ExtendedGDBusMethodInfo _goa_oauth2_based_method_info_get_access_token =
{
  {
    -1,
    (gchar *) "GetAccessToken",
    NULL,
    (GDBusArgInfo **) &_goa_oauth2_based_method_info_get_access_token_OUT_ARG_pointers,
    NULL
  },
  "handle-get-access-token",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _goa_oauth2_based_method_info_pointers[] =
{
  &_goa_oauth2_based_method_info_get_access_token,
  NULL
};

static const _ExtendedGDBusPropertyInfo _goa_oauth2_based_property_info_client_id =
{
  {
    -1,
    (gchar *) "ClientId",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "client-id",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_oauth2_based_property_info_client_secret =
{
  {
    -1,
    (gchar *) "ClientSecret",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "client-secret",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _goa_oauth2_based_property_info_pointers[] =
{
  &_goa_oauth2_based_property_info_client_id,
  &_goa_oauth2_based_property_info_client_secret,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_oauth2_based_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.OAuth2Based",
    (GDBusMethodInfo **) &_goa_oauth2_based_method_info_pointers,
    NULL,
    (GDBusPropertyInfo **) &_goa_oauth2_based_property_info_pointers,
    NULL
  },
  "oauth2-based",
};


/**
 * goa_oauth2_based_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_oauth2_based_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_oauth2_based_interface_info.parent_struct;
}

/**
 * goa_oauth2_based_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaOAuth2Based interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_oauth2_based_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "client-id");
  g_object_class_override_property (klass, property_id_begin++, "client-secret");
  return property_id_begin - 1;
}



/**
 * GoaOAuth2Based:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link>.
 */

/**
 * GoaOAuth2BasedIface:
 * @parent_iface: The parent interface.
 * @handle_get_access_token: Handler for the #GoaOAuth2Based::handle-get-access-token signal.
 * @get_client_id: Getter for the #GoaOAuth2Based:client-id property.
 * @get_client_secret: Getter for the #GoaOAuth2Based:client-secret property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link>.
 */

static void
goa_oauth2_based_default_init (GoaOAuth2BasedIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * GoaOAuth2Based::handle-get-access-token:
   * @object: A #GoaOAuth2Based.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuth2Based.GetAccessToken">GetAccessToken()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call goa_oauth2_based_complete_get_access_token() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-access-token",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (GoaOAuth2BasedIface, handle_get_access_token),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject properties for D-Bus properties: */
  /**
   * GoaOAuth2Based:client-id:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientId">"ClientId"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("client-id", "ClientId", "ClientId", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaOAuth2Based:client-secret:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientSecret">"ClientSecret"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("client-secret", "ClientSecret", "ClientSecret", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef GoaOAuth2BasedIface GoaOAuth2BasedInterface;
G_DEFINE_INTERFACE (GoaOAuth2Based, goa_oauth2_based, G_TYPE_OBJECT);

/**
 * goa_oauth2_based_get_client_id: (skip)
 * @object: A #GoaOAuth2Based.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientId">"ClientId"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_oauth2_based_dup_client_id() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_oauth2_based_get_client_id (GoaOAuth2Based *object)
{
  return GOA_OAUTH2_BASED_GET_IFACE (object)->get_client_id (object);
}

/**
 * goa_oauth2_based_dup_client_id: (skip)
 * @object: A #GoaOAuth2Based.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientId">"ClientId"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_oauth2_based_dup_client_id (GoaOAuth2Based *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "client-id", &value, NULL);
  return value;
}

/**
 * goa_oauth2_based_set_client_id: (skip)
 * @object: A #GoaOAuth2Based.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientId">"ClientId"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_oauth2_based_set_client_id (GoaOAuth2Based *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "client-id", value, NULL);
}

/**
 * goa_oauth2_based_get_client_secret: (skip)
 * @object: A #GoaOAuth2Based.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientSecret">"ClientSecret"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_oauth2_based_dup_client_secret() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_oauth2_based_get_client_secret (GoaOAuth2Based *object)
{
  return GOA_OAUTH2_BASED_GET_IFACE (object)->get_client_secret (object);
}

/**
 * goa_oauth2_based_dup_client_secret: (skip)
 * @object: A #GoaOAuth2Based.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientSecret">"ClientSecret"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_oauth2_based_dup_client_secret (GoaOAuth2Based *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "client-secret", &value, NULL);
  return value;
}

/**
 * goa_oauth2_based_set_client_secret: (skip)
 * @object: A #GoaOAuth2Based.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientSecret">"ClientSecret"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_oauth2_based_set_client_secret (GoaOAuth2Based *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "client-secret", value, NULL);
}

/**
 * goa_oauth2_based_call_get_access_token:
 * @proxy: A #GoaOAuth2BasedProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuth2Based.GetAccessToken">GetAccessToken()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_oauth2_based_call_get_access_token_finish() to get the result of the operation.
 *
 * See goa_oauth2_based_call_get_access_token_sync() for the synchronous, blocking version of this method.
 */
void
goa_oauth2_based_call_get_access_token (
    GoaOAuth2Based *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GetAccessToken",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * goa_oauth2_based_call_get_access_token_finish:
 * @proxy: A #GoaOAuth2BasedProxy.
 * @out_access_token: (out): Return location for return parameter or %NULL to ignore.
 * @out_expires_in: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_oauth2_based_call_get_access_token().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with goa_oauth2_based_call_get_access_token().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
goa_oauth2_based_call_get_access_token_finish (
    GoaOAuth2Based *proxy,
    gchar **out_access_token,
    gint *out_expires_in,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(si)",
                 out_access_token,
                 out_expires_in);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_oauth2_based_call_get_access_token_sync:
 * @proxy: A #GoaOAuth2BasedProxy.
 * @out_access_token: (out): Return location for return parameter or %NULL to ignore.
 * @out_expires_in: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuth2Based.GetAccessToken">GetAccessToken()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See goa_oauth2_based_call_get_access_token() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
goa_oauth2_based_call_get_access_token_sync (
    GoaOAuth2Based *proxy,
    gchar **out_access_token,
    gint *out_expires_in,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GetAccessToken",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(si)",
                 out_access_token,
                 out_expires_in);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_oauth2_based_complete_get_access_token:
 * @object: A #GoaOAuth2Based.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @access_token: Parameter to return.
 * @expires_in: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuth2Based.GetAccessToken">GetAccessToken()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
goa_oauth2_based_complete_get_access_token (
    GoaOAuth2Based *object,
    GDBusMethodInvocation *invocation,
    const gchar *access_token,
    gint expires_in)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(si)",
                   access_token,
                   expires_in));
}

/* ------------------------------------------------------------------------ */

/**
 * GoaOAuth2BasedProxy:
 *
 * The #GoaOAuth2BasedProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaOAuth2BasedProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaOAuth2BasedProxy.
 */

struct _GoaOAuth2BasedProxyPrivate
{
  GData *qdata;
};

static void goa_oauth2_based_proxy_iface_init (GoaOAuth2BasedIface *iface);

G_DEFINE_TYPE_WITH_CODE (GoaOAuth2BasedProxy, goa_oauth2_based_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OAUTH2_BASED, goa_oauth2_based_proxy_iface_init));

static void
goa_oauth2_based_proxy_finalize (GObject *object)
{
  GoaOAuth2BasedProxy *proxy = GOA_OAUTH2_BASED_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_oauth2_based_proxy_parent_class)->finalize (object);
}

static void
goa_oauth2_based_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _goa_oauth2_based_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
goa_oauth2_based_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface org.gnome.OnlineAccounts.OAuth2Based: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
goa_oauth2_based_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _goa_oauth2_based_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.gnome.OnlineAccounts.OAuth2Based", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) goa_oauth2_based_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
goa_oauth2_based_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_oauth2_based_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_OAUTH2_BASED);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_OAUTH2_BASED);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_oauth2_based_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaOAuth2BasedProxy *proxy = GOA_OAUTH2_BASED_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth2_based_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth2_based_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
goa_oauth2_based_proxy_get_client_id (GoaOAuth2Based *object)
{
  GoaOAuth2BasedProxy *proxy = GOA_OAUTH2_BASED_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ClientId");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_oauth2_based_proxy_get_client_secret (GoaOAuth2Based *object)
{
  GoaOAuth2BasedProxy *proxy = GOA_OAUTH2_BASED_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ClientSecret");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
goa_oauth2_based_proxy_init (GoaOAuth2BasedProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_OAUTH2_BASED_PROXY, GoaOAuth2BasedProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_oauth2_based_interface_info ());
}

static void
goa_oauth2_based_proxy_class_init (GoaOAuth2BasedProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (GoaOAuth2BasedProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_oauth2_based_proxy_finalize;
  gobject_class->get_property = goa_oauth2_based_proxy_get_property;
  gobject_class->set_property = goa_oauth2_based_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_oauth2_based_proxy_g_signal;
  proxy_class->g_properties_changed = goa_oauth2_based_proxy_g_properties_changed;


  goa_oauth2_based_override_properties (gobject_class, 1);
}

static void
goa_oauth2_based_proxy_iface_init (GoaOAuth2BasedIface *iface)
{
  iface->get_client_id = goa_oauth2_based_proxy_get_client_id;
  iface->get_client_secret = goa_oauth2_based_proxy_get_client_secret;
}

/**
 * goa_oauth2_based_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_oauth2_based_proxy_new_finish() to get the result of the operation.
 *
 * See goa_oauth2_based_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_oauth2_based_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_OAUTH2_BASED_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuth2Based", NULL);
}

/**
 * goa_oauth2_based_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_oauth2_based_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_oauth2_based_proxy_new().
 *
 * Returns: (transfer full) (type GoaOAuth2BasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuth2Based *
goa_oauth2_based_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_OAUTH2_BASED (ret);
  else
    return NULL;
}

/**
 * goa_oauth2_based_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_oauth2_based_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaOAuth2BasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuth2Based *
goa_oauth2_based_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_OAUTH2_BASED_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuth2Based", NULL);
  if (ret != NULL)
    return GOA_OAUTH2_BASED (ret);
  else
    return NULL;
}


/**
 * goa_oauth2_based_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_oauth2_based_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_oauth2_based_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_oauth2_based_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_oauth2_based_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_OAUTH2_BASED_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuth2Based", NULL);
}

/**
 * goa_oauth2_based_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_oauth2_based_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_oauth2_based_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaOAuth2BasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuth2Based *
goa_oauth2_based_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_OAUTH2_BASED (ret);
  else
    return NULL;
}

/**
 * goa_oauth2_based_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_oauth2_based_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_oauth2_based_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaOAuth2BasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuth2Based *
goa_oauth2_based_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_OAUTH2_BASED_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuth2Based", NULL);
  if (ret != NULL)
    return GOA_OAUTH2_BASED (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaOAuth2BasedSkeleton:
 *
 * The #GoaOAuth2BasedSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaOAuth2BasedSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaOAuth2BasedSkeleton.
 */

struct _GoaOAuth2BasedSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_oauth2_based_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_OAUTH2_BASED);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_OAUTH2_BASED);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_oauth2_based_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth2_based_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_oauth2_based_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth2_based_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_oauth2_based_skeleton_vtable =
{
  _goa_oauth2_based_skeleton_handle_method_call,
  _goa_oauth2_based_skeleton_handle_get_property,
  _goa_oauth2_based_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
goa_oauth2_based_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return goa_oauth2_based_interface_info ();
}

static GDBusInterfaceVTable *
goa_oauth2_based_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_goa_oauth2_based_skeleton_vtable;
}

static GVariant *
goa_oauth2_based_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_oauth2_based_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_oauth2_based_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_oauth2_based_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_oauth2_based_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.OAuth2Based", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _goa_oauth2_based_emit_changed (gpointer user_data);

static void
goa_oauth2_based_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _goa_oauth2_based_emit_changed (skeleton);
}

static void goa_oauth2_based_skeleton_iface_init (GoaOAuth2BasedIface *iface);
G_DEFINE_TYPE_WITH_CODE (GoaOAuth2BasedSkeleton, goa_oauth2_based_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OAUTH2_BASED, goa_oauth2_based_skeleton_iface_init));

static void
goa_oauth2_based_skeleton_finalize (GObject *object)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_oauth2_based_skeleton_parent_class)->finalize (object);
}

static void
goa_oauth2_based_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_goa_oauth2_based_emit_changed (gpointer user_data)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.gnome.OnlineAccounts.OAuth2Based",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_goa_oauth2_based_schedule_emit_changed (GoaOAuth2BasedSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
goa_oauth2_based_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _goa_oauth2_based_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
goa_oauth2_based_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _goa_oauth2_based_schedule_emit_changed (skeleton, _goa_oauth2_based_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
goa_oauth2_based_skeleton_init (GoaOAuth2BasedSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_OAUTH2_BASED_SKELETON, GoaOAuth2BasedSkeletonPrivate);
  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
}

static const gchar *
goa_oauth2_based_skeleton_get_client_id (GoaOAuth2Based *object)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_oauth2_based_skeleton_get_client_secret (GoaOAuth2Based *object)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
goa_oauth2_based_skeleton_class_init (GoaOAuth2BasedSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (GoaOAuth2BasedSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_oauth2_based_skeleton_finalize;
  gobject_class->get_property = goa_oauth2_based_skeleton_get_property;
  gobject_class->set_property = goa_oauth2_based_skeleton_set_property;
  gobject_class->notify       = goa_oauth2_based_skeleton_notify;


  goa_oauth2_based_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_oauth2_based_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_oauth2_based_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_oauth2_based_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_oauth2_based_skeleton_dbus_interface_get_vtable;
}

static void
goa_oauth2_based_skeleton_iface_init (GoaOAuth2BasedIface *iface)
{
  iface->get_client_id = goa_oauth2_based_skeleton_get_client_id;
  iface->get_client_secret = goa_oauth2_based_skeleton_get_client_secret;
}

/**
 * goa_oauth2_based_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link>.
 *
 * Returns: (transfer full) (type GoaOAuth2BasedSkeleton): The skeleton object.
 */
GoaOAuth2Based *
goa_oauth2_based_skeleton_new (void)
{
  return GOA_OAUTH2_BASED (g_object_new (GOA_TYPE_OAUTH2_BASED_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.OAuthBased
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaOAuthBased
 * @title: GoaOAuthBased
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.OAuthBased D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.OAuthBased ---- */

static const _ExtendedGDBusArgInfo _goa_oauth_based_method_info_get_access_token_OUT_ARG_access_token =
{
  {
    -1,
    (gchar *) "access_token",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_oauth_based_method_info_get_access_token_OUT_ARG_access_token_secret =
{
  {
    -1,
    (gchar *) "access_token_secret",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_oauth_based_method_info_get_access_token_OUT_ARG_expires_in =
{
  {
    -1,
    (gchar *) "expires_in",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _goa_oauth_based_method_info_get_access_token_OUT_ARG_pointers[] =
{
  &_goa_oauth_based_method_info_get_access_token_OUT_ARG_access_token,
  &_goa_oauth_based_method_info_get_access_token_OUT_ARG_access_token_secret,
  &_goa_oauth_based_method_info_get_access_token_OUT_ARG_expires_in,
  NULL
};

static const _ExtendedGDBusMethodInfo _goa_oauth_based_method_info_get_access_token =
{
  {
    -1,
    (gchar *) "GetAccessToken",
    NULL,
    (GDBusArgInfo **) &_goa_oauth_based_method_info_get_access_token_OUT_ARG_pointers,
    NULL
  },
  "handle-get-access-token",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _goa_oauth_based_method_info_pointers[] =
{
  &_goa_oauth_based_method_info_get_access_token,
  NULL
};

static const _ExtendedGDBusPropertyInfo _goa_oauth_based_property_info_consumer_key =
{
  {
    -1,
    (gchar *) "ConsumerKey",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "consumer-key",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_oauth_based_property_info_consumer_secret =
{
  {
    -1,
    (gchar *) "ConsumerSecret",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "consumer-secret",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _goa_oauth_based_property_info_pointers[] =
{
  &_goa_oauth_based_property_info_consumer_key,
  &_goa_oauth_based_property_info_consumer_secret,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_oauth_based_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.OAuthBased",
    (GDBusMethodInfo **) &_goa_oauth_based_method_info_pointers,
    NULL,
    (GDBusPropertyInfo **) &_goa_oauth_based_property_info_pointers,
    NULL
  },
  "oauth-based",
};


/**
 * goa_oauth_based_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_oauth_based_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_oauth_based_interface_info.parent_struct;
}

/**
 * goa_oauth_based_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaOAuthBased interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_oauth_based_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "consumer-key");
  g_object_class_override_property (klass, property_id_begin++, "consumer-secret");
  return property_id_begin - 1;
}



/**
 * GoaOAuthBased:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link>.
 */

/**
 * GoaOAuthBasedIface:
 * @parent_iface: The parent interface.
 * @handle_get_access_token: Handler for the #GoaOAuthBased::handle-get-access-token signal.
 * @get_consumer_key: Getter for the #GoaOAuthBased:consumer-key property.
 * @get_consumer_secret: Getter for the #GoaOAuthBased:consumer-secret property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link>.
 */

static void
goa_oauth_based_default_init (GoaOAuthBasedIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * GoaOAuthBased::handle-get-access-token:
   * @object: A #GoaOAuthBased.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuthBased.GetAccessToken">GetAccessToken()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call goa_oauth_based_complete_get_access_token() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-access-token",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (GoaOAuthBasedIface, handle_get_access_token),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject properties for D-Bus properties: */
  /**
   * GoaOAuthBased:consumer-key:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerKey">"ConsumerKey"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("consumer-key", "ConsumerKey", "ConsumerKey", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaOAuthBased:consumer-secret:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerSecret">"ConsumerSecret"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("consumer-secret", "ConsumerSecret", "ConsumerSecret", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef GoaOAuthBasedIface GoaOAuthBasedInterface;
G_DEFINE_INTERFACE (GoaOAuthBased, goa_oauth_based, G_TYPE_OBJECT);

/**
 * goa_oauth_based_get_consumer_key: (skip)
 * @object: A #GoaOAuthBased.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerKey">"ConsumerKey"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_oauth_based_dup_consumer_key() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_oauth_based_get_consumer_key (GoaOAuthBased *object)
{
  return GOA_OAUTH_BASED_GET_IFACE (object)->get_consumer_key (object);
}

/**
 * goa_oauth_based_dup_consumer_key: (skip)
 * @object: A #GoaOAuthBased.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerKey">"ConsumerKey"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_oauth_based_dup_consumer_key (GoaOAuthBased *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "consumer-key", &value, NULL);
  return value;
}

/**
 * goa_oauth_based_set_consumer_key: (skip)
 * @object: A #GoaOAuthBased.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerKey">"ConsumerKey"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_oauth_based_set_consumer_key (GoaOAuthBased *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "consumer-key", value, NULL);
}

/**
 * goa_oauth_based_get_consumer_secret: (skip)
 * @object: A #GoaOAuthBased.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerSecret">"ConsumerSecret"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_oauth_based_dup_consumer_secret() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_oauth_based_get_consumer_secret (GoaOAuthBased *object)
{
  return GOA_OAUTH_BASED_GET_IFACE (object)->get_consumer_secret (object);
}

/**
 * goa_oauth_based_dup_consumer_secret: (skip)
 * @object: A #GoaOAuthBased.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerSecret">"ConsumerSecret"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_oauth_based_dup_consumer_secret (GoaOAuthBased *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "consumer-secret", &value, NULL);
  return value;
}

/**
 * goa_oauth_based_set_consumer_secret: (skip)
 * @object: A #GoaOAuthBased.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerSecret">"ConsumerSecret"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_oauth_based_set_consumer_secret (GoaOAuthBased *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "consumer-secret", value, NULL);
}

/**
 * goa_oauth_based_call_get_access_token:
 * @proxy: A #GoaOAuthBasedProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuthBased.GetAccessToken">GetAccessToken()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_oauth_based_call_get_access_token_finish() to get the result of the operation.
 *
 * See goa_oauth_based_call_get_access_token_sync() for the synchronous, blocking version of this method.
 */
void
goa_oauth_based_call_get_access_token (
    GoaOAuthBased *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GetAccessToken",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * goa_oauth_based_call_get_access_token_finish:
 * @proxy: A #GoaOAuthBasedProxy.
 * @out_access_token: (out): Return location for return parameter or %NULL to ignore.
 * @out_access_token_secret: (out): Return location for return parameter or %NULL to ignore.
 * @out_expires_in: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_oauth_based_call_get_access_token().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with goa_oauth_based_call_get_access_token().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
goa_oauth_based_call_get_access_token_finish (
    GoaOAuthBased *proxy,
    gchar **out_access_token,
    gchar **out_access_token_secret,
    gint *out_expires_in,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(ssi)",
                 out_access_token,
                 out_access_token_secret,
                 out_expires_in);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_oauth_based_call_get_access_token_sync:
 * @proxy: A #GoaOAuthBasedProxy.
 * @out_access_token: (out): Return location for return parameter or %NULL to ignore.
 * @out_access_token_secret: (out): Return location for return parameter or %NULL to ignore.
 * @out_expires_in: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuthBased.GetAccessToken">GetAccessToken()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See goa_oauth_based_call_get_access_token() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
goa_oauth_based_call_get_access_token_sync (
    GoaOAuthBased *proxy,
    gchar **out_access_token,
    gchar **out_access_token_secret,
    gint *out_expires_in,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GetAccessToken",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(ssi)",
                 out_access_token,
                 out_access_token_secret,
                 out_expires_in);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_oauth_based_complete_get_access_token:
 * @object: A #GoaOAuthBased.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @access_token: Parameter to return.
 * @access_token_secret: Parameter to return.
 * @expires_in: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuthBased.GetAccessToken">GetAccessToken()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
goa_oauth_based_complete_get_access_token (
    GoaOAuthBased *object,
    GDBusMethodInvocation *invocation,
    const gchar *access_token,
    const gchar *access_token_secret,
    gint expires_in)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(ssi)",
                   access_token,
                   access_token_secret,
                   expires_in));
}

/* ------------------------------------------------------------------------ */

/**
 * GoaOAuthBasedProxy:
 *
 * The #GoaOAuthBasedProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaOAuthBasedProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaOAuthBasedProxy.
 */

struct _GoaOAuthBasedProxyPrivate
{
  GData *qdata;
};

static void goa_oauth_based_proxy_iface_init (GoaOAuthBasedIface *iface);

G_DEFINE_TYPE_WITH_CODE (GoaOAuthBasedProxy, goa_oauth_based_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OAUTH_BASED, goa_oauth_based_proxy_iface_init));

static void
goa_oauth_based_proxy_finalize (GObject *object)
{
  GoaOAuthBasedProxy *proxy = GOA_OAUTH_BASED_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_oauth_based_proxy_parent_class)->finalize (object);
}

static void
goa_oauth_based_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _goa_oauth_based_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
goa_oauth_based_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface org.gnome.OnlineAccounts.OAuthBased: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
goa_oauth_based_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _goa_oauth_based_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.gnome.OnlineAccounts.OAuthBased", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) goa_oauth_based_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
goa_oauth_based_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_oauth_based_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_OAUTH_BASED);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_OAUTH_BASED);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_oauth_based_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaOAuthBasedProxy *proxy = GOA_OAUTH_BASED_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth_based_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth_based_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
goa_oauth_based_proxy_get_consumer_key (GoaOAuthBased *object)
{
  GoaOAuthBasedProxy *proxy = GOA_OAUTH_BASED_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ConsumerKey");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_oauth_based_proxy_get_consumer_secret (GoaOAuthBased *object)
{
  GoaOAuthBasedProxy *proxy = GOA_OAUTH_BASED_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ConsumerSecret");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
goa_oauth_based_proxy_init (GoaOAuthBasedProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_OAUTH_BASED_PROXY, GoaOAuthBasedProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_oauth_based_interface_info ());
}

static void
goa_oauth_based_proxy_class_init (GoaOAuthBasedProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (GoaOAuthBasedProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_oauth_based_proxy_finalize;
  gobject_class->get_property = goa_oauth_based_proxy_get_property;
  gobject_class->set_property = goa_oauth_based_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_oauth_based_proxy_g_signal;
  proxy_class->g_properties_changed = goa_oauth_based_proxy_g_properties_changed;


  goa_oauth_based_override_properties (gobject_class, 1);
}

static void
goa_oauth_based_proxy_iface_init (GoaOAuthBasedIface *iface)
{
  iface->get_consumer_key = goa_oauth_based_proxy_get_consumer_key;
  iface->get_consumer_secret = goa_oauth_based_proxy_get_consumer_secret;
}

/**
 * goa_oauth_based_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_oauth_based_proxy_new_finish() to get the result of the operation.
 *
 * See goa_oauth_based_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_oauth_based_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_OAUTH_BASED_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuthBased", NULL);
}

/**
 * goa_oauth_based_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_oauth_based_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_oauth_based_proxy_new().
 *
 * Returns: (transfer full) (type GoaOAuthBasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuthBased *
goa_oauth_based_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_OAUTH_BASED (ret);
  else
    return NULL;
}

/**
 * goa_oauth_based_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_oauth_based_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaOAuthBasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuthBased *
goa_oauth_based_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_OAUTH_BASED_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuthBased", NULL);
  if (ret != NULL)
    return GOA_OAUTH_BASED (ret);
  else
    return NULL;
}


/**
 * goa_oauth_based_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_oauth_based_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_oauth_based_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_oauth_based_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_oauth_based_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_OAUTH_BASED_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuthBased", NULL);
}

/**
 * goa_oauth_based_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_oauth_based_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_oauth_based_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaOAuthBasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuthBased *
goa_oauth_based_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_OAUTH_BASED (ret);
  else
    return NULL;
}

/**
 * goa_oauth_based_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_oauth_based_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_oauth_based_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaOAuthBasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuthBased *
goa_oauth_based_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_OAUTH_BASED_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuthBased", NULL);
  if (ret != NULL)
    return GOA_OAUTH_BASED (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaOAuthBasedSkeleton:
 *
 * The #GoaOAuthBasedSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaOAuthBasedSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaOAuthBasedSkeleton.
 */

struct _GoaOAuthBasedSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_oauth_based_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_OAUTH_BASED);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_OAUTH_BASED);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_oauth_based_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth_based_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_oauth_based_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth_based_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_oauth_based_skeleton_vtable =
{
  _goa_oauth_based_skeleton_handle_method_call,
  _goa_oauth_based_skeleton_handle_get_property,
  _goa_oauth_based_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
goa_oauth_based_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return goa_oauth_based_interface_info ();
}

static GDBusInterfaceVTable *
goa_oauth_based_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_goa_oauth_based_skeleton_vtable;
}

static GVariant *
goa_oauth_based_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_oauth_based_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_oauth_based_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_oauth_based_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_oauth_based_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.OAuthBased", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _goa_oauth_based_emit_changed (gpointer user_data);

static void
goa_oauth_based_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _goa_oauth_based_emit_changed (skeleton);
}

static void goa_oauth_based_skeleton_iface_init (GoaOAuthBasedIface *iface);
G_DEFINE_TYPE_WITH_CODE (GoaOAuthBasedSkeleton, goa_oauth_based_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OAUTH_BASED, goa_oauth_based_skeleton_iface_init));

static void
goa_oauth_based_skeleton_finalize (GObject *object)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_oauth_based_skeleton_parent_class)->finalize (object);
}

static void
goa_oauth_based_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_goa_oauth_based_emit_changed (gpointer user_data)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.gnome.OnlineAccounts.OAuthBased",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_goa_oauth_based_schedule_emit_changed (GoaOAuthBasedSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
goa_oauth_based_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _goa_oauth_based_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
goa_oauth_based_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _goa_oauth_based_schedule_emit_changed (skeleton, _goa_oauth_based_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
goa_oauth_based_skeleton_init (GoaOAuthBasedSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_OAUTH_BASED_SKELETON, GoaOAuthBasedSkeletonPrivate);
  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
}

static const gchar *
goa_oauth_based_skeleton_get_consumer_key (GoaOAuthBased *object)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_oauth_based_skeleton_get_consumer_secret (GoaOAuthBased *object)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
goa_oauth_based_skeleton_class_init (GoaOAuthBasedSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (GoaOAuthBasedSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_oauth_based_skeleton_finalize;
  gobject_class->get_property = goa_oauth_based_skeleton_get_property;
  gobject_class->set_property = goa_oauth_based_skeleton_set_property;
  gobject_class->notify       = goa_oauth_based_skeleton_notify;


  goa_oauth_based_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_oauth_based_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_oauth_based_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_oauth_based_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_oauth_based_skeleton_dbus_interface_get_vtable;
}

static void
goa_oauth_based_skeleton_iface_init (GoaOAuthBasedIface *iface)
{
  iface->get_consumer_key = goa_oauth_based_skeleton_get_consumer_key;
  iface->get_consumer_secret = goa_oauth_based_skeleton_get_consumer_secret;
}

/**
 * goa_oauth_based_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link>.
 *
 * Returns: (transfer full) (type GoaOAuthBasedSkeleton): The skeleton object.
 */
GoaOAuthBased *
goa_oauth_based_skeleton_new (void)
{
  return GOA_OAUTH_BASED (g_object_new (GOA_TYPE_OAUTH_BASED_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.PasswordBased
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaPasswordBased
 * @title: GoaPasswordBased
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.PasswordBased D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.PasswordBased ---- */

static const _ExtendedGDBusArgInfo _goa_password_based_method_info_get_password_IN_ARG_id =
{
  {
    -1,
    (gchar *) "id",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _goa_password_based_method_info_get_password_IN_ARG_pointers[] =
{
  &_goa_password_based_method_info_get_password_IN_ARG_id,
  NULL
};

static const _ExtendedGDBusArgInfo _goa_password_based_method_info_get_password_OUT_ARG_password =
{
  {
    -1,
    (gchar *) "password",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _goa_password_based_method_info_get_password_OUT_ARG_pointers[] =
{
  &_goa_password_based_method_info_get_password_OUT_ARG_password,
  NULL
};

static const _ExtendedGDBusMethodInfo _goa_password_based_method_info_get_password =
{
  {
    -1,
    (gchar *) "GetPassword",
    (GDBusArgInfo **) &_goa_password_based_method_info_get_password_IN_ARG_pointers,
    (GDBusArgInfo **) &_goa_password_based_method_info_get_password_OUT_ARG_pointers,
    NULL
  },
  "handle-get-password",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _goa_password_based_method_info_pointers[] =
{
  &_goa_password_based_method_info_get_password,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_password_based_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.PasswordBased",
    (GDBusMethodInfo **) &_goa_password_based_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "password-based",
};


/**
 * goa_password_based_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Since: 3.6.0
 */
GDBusInterfaceInfo *
goa_password_based_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_password_based_interface_info.parent_struct;
}

/**
 * goa_password_based_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaPasswordBased interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Since: 3.6.0
 */
guint
goa_password_based_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaPasswordBased:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link>.
 *
 * Since: 3.6.0
 */

/**
 * GoaPasswordBasedIface:
 * @parent_iface: The parent interface.
 * @handle_get_password: Handler for the #GoaPasswordBased::handle-get-password signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link>.
 *
 * Since: 3.6.0
 */

static void
goa_password_based_default_init (GoaPasswordBasedIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * GoaPasswordBased::handle-get-password:
   * @object: A #GoaPasswordBased.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_id: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-OnlineAccounts-PasswordBased.GetPassword">GetPassword()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call goa_password_based_complete_get_password() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   *
   * Since: 3.6.0
   */
  g_signal_new ("handle-get-password",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (GoaPasswordBasedIface, handle_get_password),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

}

typedef GoaPasswordBasedIface GoaPasswordBasedInterface;
G_DEFINE_INTERFACE (GoaPasswordBased, goa_password_based, G_TYPE_OBJECT);

/**
 * goa_password_based_call_get_password:
 * @proxy: A #GoaPasswordBasedProxy.
 * @arg_id: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-PasswordBased.GetPassword">GetPassword()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_password_based_call_get_password_finish() to get the result of the operation.
 *
 * See goa_password_based_call_get_password_sync() for the synchronous, blocking version of this method.
 *
 * Since: 3.6.0
 */
void
goa_password_based_call_get_password (
    GoaPasswordBased *proxy,
    const gchar *arg_id,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GetPassword",
    g_variant_new ("(s)",
                   arg_id),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * goa_password_based_call_get_password_finish:
 * @proxy: A #GoaPasswordBasedProxy.
 * @out_password: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_password_based_call_get_password().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with goa_password_based_call_get_password().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Since: 3.6.0
 */
gboolean
goa_password_based_call_get_password_finish (
    GoaPasswordBased *proxy,
    gchar **out_password,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_password);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_password_based_call_get_password_sync:
 * @proxy: A #GoaPasswordBasedProxy.
 * @arg_id: Argument to pass with the method invocation.
 * @out_password: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-PasswordBased.GetPassword">GetPassword()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See goa_password_based_call_get_password() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Since: 3.6.0
 */
gboolean
goa_password_based_call_get_password_sync (
    GoaPasswordBased *proxy,
    const gchar *arg_id,
    gchar **out_password,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GetPassword",
    g_variant_new ("(s)",
                   arg_id),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_password);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_password_based_complete_get_password:
 * @object: A #GoaPasswordBased.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @password: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-OnlineAccounts-PasswordBased.GetPassword">GetPassword()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 *
 * Since: 3.6.0
 */
void
goa_password_based_complete_get_password (
    GoaPasswordBased *object,
    GDBusMethodInvocation *invocation,
    const gchar *password)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   password));
}

/* ------------------------------------------------------------------------ */

/**
 * GoaPasswordBasedProxy:
 *
 * The #GoaPasswordBasedProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.6.0
 */

/**
 * GoaPasswordBasedProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaPasswordBasedProxy.
 *
 * Since: 3.6.0
 */

struct _GoaPasswordBasedProxyPrivate
{
  GData *qdata;
};

static void goa_password_based_proxy_iface_init (GoaPasswordBasedIface *iface);

G_DEFINE_TYPE_WITH_CODE (GoaPasswordBasedProxy, goa_password_based_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_PASSWORD_BASED, goa_password_based_proxy_iface_init));

static void
goa_password_based_proxy_finalize (GObject *object)
{
  GoaPasswordBasedProxy *proxy = GOA_PASSWORD_BASED_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_password_based_proxy_parent_class)->finalize (object);
}

static void
goa_password_based_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
goa_password_based_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
goa_password_based_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_password_based_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_PASSWORD_BASED);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_PASSWORD_BASED);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_password_based_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaPasswordBasedProxy *proxy = GOA_PASSWORD_BASED_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_password_based_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_password_based_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_password_based_proxy_init (GoaPasswordBasedProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_PASSWORD_BASED_PROXY, GoaPasswordBasedProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_password_based_interface_info ());
}

static void
goa_password_based_proxy_class_init (GoaPasswordBasedProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (GoaPasswordBasedProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_password_based_proxy_finalize;
  gobject_class->get_property = goa_password_based_proxy_get_property;
  gobject_class->set_property = goa_password_based_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_password_based_proxy_g_signal;
  proxy_class->g_properties_changed = goa_password_based_proxy_g_properties_changed;

}

static void
goa_password_based_proxy_iface_init (GoaPasswordBasedIface *iface)
{
}

/**
 * goa_password_based_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_password_based_proxy_new_finish() to get the result of the operation.
 *
 * See goa_password_based_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.6.0
 */
void
goa_password_based_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_PASSWORD_BASED_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.PasswordBased", NULL);
}

/**
 * goa_password_based_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_password_based_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_password_based_proxy_new().
 *
 * Returns: (transfer full) (type GoaPasswordBasedProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaPasswordBased *
goa_password_based_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_PASSWORD_BASED (ret);
  else
    return NULL;
}

/**
 * goa_password_based_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_password_based_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaPasswordBasedProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaPasswordBased *
goa_password_based_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_PASSWORD_BASED_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.PasswordBased", NULL);
  if (ret != NULL)
    return GOA_PASSWORD_BASED (ret);
  else
    return NULL;
}


/**
 * goa_password_based_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_password_based_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_password_based_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_password_based_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.6.0
 */
void
goa_password_based_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_PASSWORD_BASED_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.PasswordBased", NULL);
}

/**
 * goa_password_based_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_password_based_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_password_based_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaPasswordBasedProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaPasswordBased *
goa_password_based_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_PASSWORD_BASED (ret);
  else
    return NULL;
}

/**
 * goa_password_based_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_password_based_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_password_based_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaPasswordBasedProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaPasswordBased *
goa_password_based_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_PASSWORD_BASED_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.PasswordBased", NULL);
  if (ret != NULL)
    return GOA_PASSWORD_BASED (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaPasswordBasedSkeleton:
 *
 * The #GoaPasswordBasedSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.6.0
 */

/**
 * GoaPasswordBasedSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaPasswordBasedSkeleton.
 *
 * Since: 3.6.0
 */

struct _GoaPasswordBasedSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_password_based_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaPasswordBasedSkeleton *skeleton = GOA_PASSWORD_BASED_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_PASSWORD_BASED);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_PASSWORD_BASED);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_password_based_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaPasswordBasedSkeleton *skeleton = GOA_PASSWORD_BASED_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_password_based_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_password_based_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaPasswordBasedSkeleton *skeleton = GOA_PASSWORD_BASED_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_password_based_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_password_based_skeleton_vtable =
{
  _goa_password_based_skeleton_handle_method_call,
  _goa_password_based_skeleton_handle_get_property,
  _goa_password_based_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
goa_password_based_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return goa_password_based_interface_info ();
}

static GDBusInterfaceVTable *
goa_password_based_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_goa_password_based_skeleton_vtable;
}

static GVariant *
goa_password_based_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaPasswordBasedSkeleton *skeleton = GOA_PASSWORD_BASED_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_password_based_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_password_based_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_password_based_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_password_based_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.PasswordBased", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_password_based_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_password_based_skeleton_iface_init (GoaPasswordBasedIface *iface);
G_DEFINE_TYPE_WITH_CODE (GoaPasswordBasedSkeleton, goa_password_based_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_PASSWORD_BASED, goa_password_based_skeleton_iface_init));

static void
goa_password_based_skeleton_finalize (GObject *object)
{
  GoaPasswordBasedSkeleton *skeleton = GOA_PASSWORD_BASED_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_password_based_skeleton_parent_class)->finalize (object);
}

static void
goa_password_based_skeleton_init (GoaPasswordBasedSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_PASSWORD_BASED_SKELETON, GoaPasswordBasedSkeletonPrivate);
  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_password_based_skeleton_class_init (GoaPasswordBasedSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (GoaPasswordBasedSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_password_based_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_password_based_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_password_based_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_password_based_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_password_based_skeleton_dbus_interface_get_vtable;
}

static void
goa_password_based_skeleton_iface_init (GoaPasswordBasedIface *iface)
{
}

/**
 * goa_password_based_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link>.
 *
 * Returns: (transfer full) (type GoaPasswordBasedSkeleton): The skeleton object.
 *
 * Since: 3.6.0
 */
GoaPasswordBased *
goa_password_based_skeleton_new (void)
{
  return GOA_PASSWORD_BASED (g_object_new (GOA_TYPE_PASSWORD_BASED_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Manager
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaManager
 * @title: GoaManager
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Manager D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Manager ---- */

static const _ExtendedGDBusArgInfo _goa_manager_method_info_add_account_IN_ARG_provider =
{
  {
    -1,
    (gchar *) "provider",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_manager_method_info_add_account_IN_ARG_identity =
{
  {
    -1,
    (gchar *) "identity",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_manager_method_info_add_account_IN_ARG_presentation_identity =
{
  {
    -1,
    (gchar *) "presentation_identity",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_manager_method_info_add_account_IN_ARG_credentials =
{
  {
    -1,
    (gchar *) "credentials",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_manager_method_info_add_account_IN_ARG_details =
{
  {
    -1,
    (gchar *) "details",
    (gchar *) "a{ss}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _goa_manager_method_info_add_account_IN_ARG_pointers[] =
{
  &_goa_manager_method_info_add_account_IN_ARG_provider,
  &_goa_manager_method_info_add_account_IN_ARG_identity,
  &_goa_manager_method_info_add_account_IN_ARG_presentation_identity,
  &_goa_manager_method_info_add_account_IN_ARG_credentials,
  &_goa_manager_method_info_add_account_IN_ARG_details,
  NULL
};

static const _ExtendedGDBusArgInfo _goa_manager_method_info_add_account_OUT_ARG_account_object_path =
{
  {
    -1,
    (gchar *) "account_object_path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _goa_manager_method_info_add_account_OUT_ARG_pointers[] =
{
  &_goa_manager_method_info_add_account_OUT_ARG_account_object_path,
  NULL
};

static const _ExtendedGDBusMethodInfo _goa_manager_method_info_add_account =
{
  {
    -1,
    (gchar *) "AddAccount",
    (GDBusArgInfo **) &_goa_manager_method_info_add_account_IN_ARG_pointers,
    (GDBusArgInfo **) &_goa_manager_method_info_add_account_OUT_ARG_pointers,
    NULL
  },
  "handle-add-account",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _goa_manager_method_info_pointers[] =
{
  &_goa_manager_method_info_add_account,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_manager_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Manager",
    (GDBusMethodInfo **) &_goa_manager_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "manager",
};


/**
 * goa_manager_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_manager_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_manager_interface_info.parent_struct;
}

/**
 * goa_manager_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaManager interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_manager_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaManager:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link>.
 */

/**
 * GoaManagerIface:
 * @parent_iface: The parent interface.
 * @handle_add_account: Handler for the #GoaManager::handle-add-account signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link>.
 */

static void
goa_manager_default_init (GoaManagerIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * GoaManager::handle-add-account:
   * @object: A #GoaManager.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_provider: Argument passed by remote caller.
   * @arg_identity: Argument passed by remote caller.
   * @arg_presentation_identity: Argument passed by remote caller.
   * @arg_credentials: Argument passed by remote caller.
   * @arg_details: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Manager.AddAccount">AddAccount()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call goa_manager_complete_add_account() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-add-account",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (GoaManagerIface, handle_add_account),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    6,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_VARIANT, G_TYPE_VARIANT);

}

typedef GoaManagerIface GoaManagerInterface;
G_DEFINE_INTERFACE (GoaManager, goa_manager, G_TYPE_OBJECT);

/**
 * goa_manager_call_add_account:
 * @proxy: A #GoaManagerProxy.
 * @arg_provider: Argument to pass with the method invocation.
 * @arg_identity: Argument to pass with the method invocation.
 * @arg_presentation_identity: Argument to pass with the method invocation.
 * @arg_credentials: Argument to pass with the method invocation.
 * @arg_details: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Manager.AddAccount">AddAccount()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_manager_call_add_account_finish() to get the result of the operation.
 *
 * See goa_manager_call_add_account_sync() for the synchronous, blocking version of this method.
 */
void
goa_manager_call_add_account (
    GoaManager *proxy,
    const gchar *arg_provider,
    const gchar *arg_identity,
    const gchar *arg_presentation_identity,
    GVariant *arg_credentials,
    GVariant *arg_details,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "AddAccount",
    g_variant_new ("(sss@a{sv}@a{ss})",
                   arg_provider,
                   arg_identity,
                   arg_presentation_identity,
                   arg_credentials,
                   arg_details),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * goa_manager_call_add_account_finish:
 * @proxy: A #GoaManagerProxy.
 * @out_account_object_path: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_manager_call_add_account().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with goa_manager_call_add_account().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
goa_manager_call_add_account_finish (
    GoaManager *proxy,
    gchar **out_account_object_path,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_account_object_path);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_manager_call_add_account_sync:
 * @proxy: A #GoaManagerProxy.
 * @arg_provider: Argument to pass with the method invocation.
 * @arg_identity: Argument to pass with the method invocation.
 * @arg_presentation_identity: Argument to pass with the method invocation.
 * @arg_credentials: Argument to pass with the method invocation.
 * @arg_details: Argument to pass with the method invocation.
 * @out_account_object_path: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Manager.AddAccount">AddAccount()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See goa_manager_call_add_account() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
goa_manager_call_add_account_sync (
    GoaManager *proxy,
    const gchar *arg_provider,
    const gchar *arg_identity,
    const gchar *arg_presentation_identity,
    GVariant *arg_credentials,
    GVariant *arg_details,
    gchar **out_account_object_path,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "AddAccount",
    g_variant_new ("(sss@a{sv}@a{ss})",
                   arg_provider,
                   arg_identity,
                   arg_presentation_identity,
                   arg_credentials,
                   arg_details),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_account_object_path);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_manager_complete_add_account:
 * @object: A #GoaManager.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @account_object_path: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Manager.AddAccount">AddAccount()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
goa_manager_complete_add_account (
    GoaManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *account_object_path)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(o)",
                   account_object_path));
}

/* ------------------------------------------------------------------------ */

/**
 * GoaManagerProxy:
 *
 * The #GoaManagerProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaManagerProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaManagerProxy.
 */

struct _GoaManagerProxyPrivate
{
  GData *qdata;
};

static void goa_manager_proxy_iface_init (GoaManagerIface *iface);

G_DEFINE_TYPE_WITH_CODE (GoaManagerProxy, goa_manager_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MANAGER, goa_manager_proxy_iface_init));

static void
goa_manager_proxy_finalize (GObject *object)
{
  GoaManagerProxy *proxy = GOA_MANAGER_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_manager_proxy_parent_class)->finalize (object);
}

static void
goa_manager_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
goa_manager_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
goa_manager_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_manager_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_MANAGER);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_MANAGER);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_manager_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaManagerProxy *proxy = GOA_MANAGER_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_manager_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_manager_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_manager_proxy_init (GoaManagerProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_MANAGER_PROXY, GoaManagerProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_manager_interface_info ());
}

static void
goa_manager_proxy_class_init (GoaManagerProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (GoaManagerProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_manager_proxy_finalize;
  gobject_class->get_property = goa_manager_proxy_get_property;
  gobject_class->set_property = goa_manager_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_manager_proxy_g_signal;
  proxy_class->g_properties_changed = goa_manager_proxy_g_properties_changed;

}

static void
goa_manager_proxy_iface_init (GoaManagerIface *iface)
{
}

/**
 * goa_manager_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_manager_proxy_new_finish() to get the result of the operation.
 *
 * See goa_manager_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_manager_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_MANAGER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Manager", NULL);
}

/**
 * goa_manager_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_manager_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_manager_proxy_new().
 *
 * Returns: (transfer full) (type GoaManagerProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaManager *
goa_manager_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_MANAGER (ret);
  else
    return NULL;
}

/**
 * goa_manager_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_manager_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaManagerProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaManager *
goa_manager_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_MANAGER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Manager", NULL);
  if (ret != NULL)
    return GOA_MANAGER (ret);
  else
    return NULL;
}


/**
 * goa_manager_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_manager_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_manager_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_manager_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_manager_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_MANAGER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Manager", NULL);
}

/**
 * goa_manager_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_manager_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_manager_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaManagerProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaManager *
goa_manager_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_MANAGER (ret);
  else
    return NULL;
}

/**
 * goa_manager_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_manager_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_manager_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaManagerProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaManager *
goa_manager_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_MANAGER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Manager", NULL);
  if (ret != NULL)
    return GOA_MANAGER (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaManagerSkeleton:
 *
 * The #GoaManagerSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaManagerSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaManagerSkeleton.
 */

struct _GoaManagerSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_manager_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaManagerSkeleton *skeleton = GOA_MANAGER_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_MANAGER);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_MANAGER);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_manager_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaManagerSkeleton *skeleton = GOA_MANAGER_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_manager_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_manager_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaManagerSkeleton *skeleton = GOA_MANAGER_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_manager_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_manager_skeleton_vtable =
{
  _goa_manager_skeleton_handle_method_call,
  _goa_manager_skeleton_handle_get_property,
  _goa_manager_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
goa_manager_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return goa_manager_interface_info ();
}

static GDBusInterfaceVTable *
goa_manager_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_goa_manager_skeleton_vtable;
}

static GVariant *
goa_manager_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaManagerSkeleton *skeleton = GOA_MANAGER_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_manager_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_manager_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_manager_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_manager_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Manager", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_manager_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_manager_skeleton_iface_init (GoaManagerIface *iface);
G_DEFINE_TYPE_WITH_CODE (GoaManagerSkeleton, goa_manager_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MANAGER, goa_manager_skeleton_iface_init));

static void
goa_manager_skeleton_finalize (GObject *object)
{
  GoaManagerSkeleton *skeleton = GOA_MANAGER_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_manager_skeleton_parent_class)->finalize (object);
}

static void
goa_manager_skeleton_init (GoaManagerSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_MANAGER_SKELETON, GoaManagerSkeletonPrivate);
  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_manager_skeleton_class_init (GoaManagerSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (GoaManagerSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_manager_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_manager_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_manager_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_manager_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_manager_skeleton_dbus_interface_get_vtable;
}

static void
goa_manager_skeleton_iface_init (GoaManagerIface *iface)
{
}

/**
 * goa_manager_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link>.
 *
 * Returns: (transfer full) (type GoaManagerSkeleton): The skeleton object.
 */
GoaManager *
goa_manager_skeleton_new (void)
{
  return GOA_MANAGER (g_object_new (GOA_TYPE_MANAGER_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Mail
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaMail
 * @title: GoaMail
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Mail D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Mail ---- */

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_email_address =
{
  {
    -1,
    (gchar *) "EmailAddress",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "email-address",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_imap_supported =
{
  {
    -1,
    (gchar *) "ImapSupported",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "imap-supported",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_imap_host =
{
  {
    -1,
    (gchar *) "ImapHost",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "imap-host",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_imap_use_tls =
{
  {
    -1,
    (gchar *) "ImapUseTls",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "imap-use-tls",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_imap_user_name =
{
  {
    -1,
    (gchar *) "ImapUserName",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "imap-user-name",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_smtp_supported =
{
  {
    -1,
    (gchar *) "SmtpSupported",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "smtp-supported",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_smtp_host =
{
  {
    -1,
    (gchar *) "SmtpHost",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "smtp-host",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_smtp_use_tls =
{
  {
    -1,
    (gchar *) "SmtpUseTls",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "smtp-use-tls",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_smtp_user_name =
{
  {
    -1,
    (gchar *) "SmtpUserName",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "smtp-user-name",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _goa_mail_property_info_pointers[] =
{
  &_goa_mail_property_info_email_address,
  &_goa_mail_property_info_imap_supported,
  &_goa_mail_property_info_imap_host,
  &_goa_mail_property_info_imap_use_tls,
  &_goa_mail_property_info_imap_user_name,
  &_goa_mail_property_info_smtp_supported,
  &_goa_mail_property_info_smtp_host,
  &_goa_mail_property_info_smtp_use_tls,
  &_goa_mail_property_info_smtp_user_name,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_mail_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Mail",
    NULL,
    NULL,
    (GDBusPropertyInfo **) &_goa_mail_property_info_pointers,
    NULL
  },
  "mail",
};


/**
 * goa_mail_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_mail_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_mail_interface_info.parent_struct;
}

/**
 * goa_mail_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaMail interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_mail_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "email-address");
  g_object_class_override_property (klass, property_id_begin++, "imap-supported");
  g_object_class_override_property (klass, property_id_begin++, "imap-host");
  g_object_class_override_property (klass, property_id_begin++, "imap-use-tls");
  g_object_class_override_property (klass, property_id_begin++, "imap-user-name");
  g_object_class_override_property (klass, property_id_begin++, "smtp-supported");
  g_object_class_override_property (klass, property_id_begin++, "smtp-host");
  g_object_class_override_property (klass, property_id_begin++, "smtp-use-tls");
  g_object_class_override_property (klass, property_id_begin++, "smtp-user-name");
  return property_id_begin - 1;
}



/**
 * GoaMail:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link>.
 */

/**
 * GoaMailIface:
 * @parent_iface: The parent interface.
 * @get_email_address: Getter for the #GoaMail:email-address property.
 * @get_imap_host: Getter for the #GoaMail:imap-host property.
 * @get_imap_supported: Getter for the #GoaMail:imap-supported property.
 * @get_imap_use_tls: Getter for the #GoaMail:imap-use-tls property.
 * @get_imap_user_name: Getter for the #GoaMail:imap-user-name property.
 * @get_smtp_host: Getter for the #GoaMail:smtp-host property.
 * @get_smtp_supported: Getter for the #GoaMail:smtp-supported property.
 * @get_smtp_use_tls: Getter for the #GoaMail:smtp-use-tls property.
 * @get_smtp_user_name: Getter for the #GoaMail:smtp-user-name property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link>.
 */

static void
goa_mail_default_init (GoaMailIface *iface)
{
  /* GObject properties for D-Bus properties: */
  /**
   * GoaMail:email-address:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.EmailAddress">"EmailAddress"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("email-address", "EmailAddress", "EmailAddress", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:imap-supported:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapSupported">"ImapSupported"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("imap-supported", "ImapSupported", "ImapSupported", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:imap-host:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapHost">"ImapHost"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("imap-host", "ImapHost", "ImapHost", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:imap-use-tls:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUseTls">"ImapUseTls"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("imap-use-tls", "ImapUseTls", "ImapUseTls", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:imap-user-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUserName">"ImapUserName"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("imap-user-name", "ImapUserName", "ImapUserName", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:smtp-supported:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpSupported">"SmtpSupported"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("smtp-supported", "SmtpSupported", "SmtpSupported", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:smtp-host:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpHost">"SmtpHost"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("smtp-host", "SmtpHost", "SmtpHost", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:smtp-use-tls:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUseTls">"SmtpUseTls"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("smtp-use-tls", "SmtpUseTls", "SmtpUseTls", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:smtp-user-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUserName">"SmtpUserName"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("smtp-user-name", "SmtpUserName", "SmtpUserName", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef GoaMailIface GoaMailInterface;
G_DEFINE_INTERFACE (GoaMail, goa_mail, G_TYPE_OBJECT);

/**
 * goa_mail_get_email_address: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.EmailAddress">"EmailAddress"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_mail_dup_email_address() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_mail_get_email_address (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_email_address (object);
}

/**
 * goa_mail_dup_email_address: (skip)
 * @object: A #GoaMail.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.EmailAddress">"EmailAddress"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_mail_dup_email_address (GoaMail *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "email-address", &value, NULL);
  return value;
}

/**
 * goa_mail_set_email_address: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.EmailAddress">"EmailAddress"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_email_address (GoaMail *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "email-address", value, NULL);
}

/**
 * goa_mail_get_imap_supported: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapSupported">"ImapSupported"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_mail_get_imap_supported (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_imap_supported (object);
}

/**
 * goa_mail_set_imap_supported: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapSupported">"ImapSupported"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_imap_supported (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "imap-supported", value, NULL);
}

/**
 * goa_mail_get_imap_host: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapHost">"ImapHost"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_mail_dup_imap_host() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_mail_get_imap_host (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_imap_host (object);
}

/**
 * goa_mail_dup_imap_host: (skip)
 * @object: A #GoaMail.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapHost">"ImapHost"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_mail_dup_imap_host (GoaMail *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "imap-host", &value, NULL);
  return value;
}

/**
 * goa_mail_set_imap_host: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapHost">"ImapHost"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_imap_host (GoaMail *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "imap-host", value, NULL);
}

/**
 * goa_mail_get_imap_use_tls: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUseTls">"ImapUseTls"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_mail_get_imap_use_tls (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_imap_use_tls (object);
}

/**
 * goa_mail_set_imap_use_tls: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUseTls">"ImapUseTls"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_imap_use_tls (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "imap-use-tls", value, NULL);
}

/**
 * goa_mail_get_imap_user_name: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUserName">"ImapUserName"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_mail_dup_imap_user_name() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_mail_get_imap_user_name (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_imap_user_name (object);
}

/**
 * goa_mail_dup_imap_user_name: (skip)
 * @object: A #GoaMail.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUserName">"ImapUserName"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_mail_dup_imap_user_name (GoaMail *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "imap-user-name", &value, NULL);
  return value;
}

/**
 * goa_mail_set_imap_user_name: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUserName">"ImapUserName"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_imap_user_name (GoaMail *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "imap-user-name", value, NULL);
}

/**
 * goa_mail_get_smtp_supported: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpSupported">"SmtpSupported"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_mail_get_smtp_supported (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_smtp_supported (object);
}

/**
 * goa_mail_set_smtp_supported: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpSupported">"SmtpSupported"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_smtp_supported (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "smtp-supported", value, NULL);
}

/**
 * goa_mail_get_smtp_host: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpHost">"SmtpHost"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_mail_dup_smtp_host() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_mail_get_smtp_host (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_smtp_host (object);
}

/**
 * goa_mail_dup_smtp_host: (skip)
 * @object: A #GoaMail.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpHost">"SmtpHost"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_mail_dup_smtp_host (GoaMail *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "smtp-host", &value, NULL);
  return value;
}

/**
 * goa_mail_set_smtp_host: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpHost">"SmtpHost"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_smtp_host (GoaMail *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "smtp-host", value, NULL);
}

/**
 * goa_mail_get_smtp_use_tls: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUseTls">"SmtpUseTls"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_mail_get_smtp_use_tls (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_smtp_use_tls (object);
}

/**
 * goa_mail_set_smtp_use_tls: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUseTls">"SmtpUseTls"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_smtp_use_tls (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "smtp-use-tls", value, NULL);
}

/**
 * goa_mail_get_smtp_user_name: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUserName">"SmtpUserName"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_mail_dup_smtp_user_name() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_mail_get_smtp_user_name (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_smtp_user_name (object);
}

/**
 * goa_mail_dup_smtp_user_name: (skip)
 * @object: A #GoaMail.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUserName">"SmtpUserName"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_mail_dup_smtp_user_name (GoaMail *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "smtp-user-name", &value, NULL);
  return value;
}

/**
 * goa_mail_set_smtp_user_name: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUserName">"SmtpUserName"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_smtp_user_name (GoaMail *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "smtp-user-name", value, NULL);
}

/* ------------------------------------------------------------------------ */

/**
 * GoaMailProxy:
 *
 * The #GoaMailProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaMailProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaMailProxy.
 */

struct _GoaMailProxyPrivate
{
  GData *qdata;
};

static void goa_mail_proxy_iface_init (GoaMailIface *iface);

G_DEFINE_TYPE_WITH_CODE (GoaMailProxy, goa_mail_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MAIL, goa_mail_proxy_iface_init));

static void
goa_mail_proxy_finalize (GObject *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_mail_proxy_parent_class)->finalize (object);
}

static void
goa_mail_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 9);
  info = _goa_mail_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
goa_mail_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface org.gnome.OnlineAccounts.Mail: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
goa_mail_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 9);
  info = _goa_mail_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.gnome.OnlineAccounts.Mail", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) goa_mail_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
goa_mail_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_mail_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_MAIL);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_MAIL);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_mail_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_mail_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_mail_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
goa_mail_proxy_get_email_address (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "EmailAddress");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_imap_supported (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ImapSupported");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_mail_proxy_get_imap_host (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ImapHost");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_imap_use_tls (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ImapUseTls");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_mail_proxy_get_imap_user_name (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ImapUserName");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_smtp_supported (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SmtpSupported");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_mail_proxy_get_smtp_host (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SmtpHost");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_smtp_use_tls (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SmtpUseTls");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_mail_proxy_get_smtp_user_name (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SmtpUserName");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
goa_mail_proxy_init (GoaMailProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_MAIL_PROXY, GoaMailProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_mail_interface_info ());
}

static void
goa_mail_proxy_class_init (GoaMailProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (GoaMailProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_mail_proxy_finalize;
  gobject_class->get_property = goa_mail_proxy_get_property;
  gobject_class->set_property = goa_mail_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_mail_proxy_g_signal;
  proxy_class->g_properties_changed = goa_mail_proxy_g_properties_changed;


  goa_mail_override_properties (gobject_class, 1);
}

static void
goa_mail_proxy_iface_init (GoaMailIface *iface)
{
  iface->get_email_address = goa_mail_proxy_get_email_address;
  iface->get_imap_supported = goa_mail_proxy_get_imap_supported;
  iface->get_imap_host = goa_mail_proxy_get_imap_host;
  iface->get_imap_use_tls = goa_mail_proxy_get_imap_use_tls;
  iface->get_imap_user_name = goa_mail_proxy_get_imap_user_name;
  iface->get_smtp_supported = goa_mail_proxy_get_smtp_supported;
  iface->get_smtp_host = goa_mail_proxy_get_smtp_host;
  iface->get_smtp_use_tls = goa_mail_proxy_get_smtp_use_tls;
  iface->get_smtp_user_name = goa_mail_proxy_get_smtp_user_name;
}

/**
 * goa_mail_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_mail_proxy_new_finish() to get the result of the operation.
 *
 * See goa_mail_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_mail_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_MAIL_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Mail", NULL);
}

/**
 * goa_mail_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_mail_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_mail_proxy_new().
 *
 * Returns: (transfer full) (type GoaMailProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaMail *
goa_mail_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_MAIL (ret);
  else
    return NULL;
}

/**
 * goa_mail_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_mail_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaMailProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaMail *
goa_mail_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_MAIL_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Mail", NULL);
  if (ret != NULL)
    return GOA_MAIL (ret);
  else
    return NULL;
}


/**
 * goa_mail_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_mail_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_mail_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_mail_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_mail_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_MAIL_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Mail", NULL);
}

/**
 * goa_mail_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_mail_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_mail_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaMailProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaMail *
goa_mail_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_MAIL (ret);
  else
    return NULL;
}

/**
 * goa_mail_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_mail_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_mail_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaMailProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaMail *
goa_mail_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_MAIL_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Mail", NULL);
  if (ret != NULL)
    return GOA_MAIL (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaMailSkeleton:
 *
 * The #GoaMailSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaMailSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaMailSkeleton.
 */

struct _GoaMailSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_mail_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_MAIL);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_MAIL);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_mail_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_mail_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_mail_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_mail_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_mail_skeleton_vtable =
{
  _goa_mail_skeleton_handle_method_call,
  _goa_mail_skeleton_handle_get_property,
  _goa_mail_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
goa_mail_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return goa_mail_interface_info ();
}

static GDBusInterfaceVTable *
goa_mail_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_goa_mail_skeleton_vtable;
}

static GVariant *
goa_mail_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_mail_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_mail_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_mail_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_mail_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Mail", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _goa_mail_emit_changed (gpointer user_data);

static void
goa_mail_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _goa_mail_emit_changed (skeleton);
}

static void goa_mail_skeleton_iface_init (GoaMailIface *iface);
G_DEFINE_TYPE_WITH_CODE (GoaMailSkeleton, goa_mail_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MAIL, goa_mail_skeleton_iface_init));

static void
goa_mail_skeleton_finalize (GObject *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  guint n;
  for (n = 0; n < 9; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_mail_skeleton_parent_class)->finalize (object);
}

static void
goa_mail_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 9);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_goa_mail_emit_changed (gpointer user_data)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.gnome.OnlineAccounts.Mail",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_goa_mail_schedule_emit_changed (GoaMailSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
goa_mail_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _goa_mail_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
goa_mail_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 9);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _goa_mail_schedule_emit_changed (skeleton, _goa_mail_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
goa_mail_skeleton_init (GoaMailSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_MAIL_SKELETON, GoaMailSkeletonPrivate);
  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 9);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[3], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[4], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[5], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[6], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[7], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[8], G_TYPE_STRING);
}

static const gchar *
goa_mail_skeleton_get_email_address (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_imap_supported (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_mail_skeleton_get_imap_host (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_imap_use_tls (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[3]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_mail_skeleton_get_imap_user_name (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[4]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_smtp_supported (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[5]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_mail_skeleton_get_smtp_host (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[6]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_smtp_use_tls (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[7]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_mail_skeleton_get_smtp_user_name (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[8]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
goa_mail_skeleton_class_init (GoaMailSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (GoaMailSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_mail_skeleton_finalize;
  gobject_class->get_property = goa_mail_skeleton_get_property;
  gobject_class->set_property = goa_mail_skeleton_set_property;
  gobject_class->notify       = goa_mail_skeleton_notify;


  goa_mail_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_mail_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_mail_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_mail_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_mail_skeleton_dbus_interface_get_vtable;
}

static void
goa_mail_skeleton_iface_init (GoaMailIface *iface)
{
  iface->get_email_address = goa_mail_skeleton_get_email_address;
  iface->get_imap_supported = goa_mail_skeleton_get_imap_supported;
  iface->get_imap_host = goa_mail_skeleton_get_imap_host;
  iface->get_imap_use_tls = goa_mail_skeleton_get_imap_use_tls;
  iface->get_imap_user_name = goa_mail_skeleton_get_imap_user_name;
  iface->get_smtp_supported = goa_mail_skeleton_get_smtp_supported;
  iface->get_smtp_host = goa_mail_skeleton_get_smtp_host;
  iface->get_smtp_use_tls = goa_mail_skeleton_get_smtp_use_tls;
  iface->get_smtp_user_name = goa_mail_skeleton_get_smtp_user_name;
}

/**
 * goa_mail_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link>.
 *
 * Returns: (transfer full) (type GoaMailSkeleton): The skeleton object.
 */
GoaMail *
goa_mail_skeleton_new (void)
{
  return GOA_MAIL (g_object_new (GOA_TYPE_MAIL_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Calendar
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaCalendar
 * @title: GoaCalendar
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Calendar D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Calendar ---- */

static const _ExtendedGDBusInterfaceInfo _goa_calendar_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Calendar",
    NULL,
    NULL,
    NULL,
    NULL
  },
  "calendar",
};


/**
 * goa_calendar_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_calendar_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_calendar_interface_info.parent_struct;
}

/**
 * goa_calendar_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaCalendar interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_calendar_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaCalendar:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link>.
 */

/**
 * GoaCalendarIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link>.
 */

static void
goa_calendar_default_init (GoaCalendarIface *iface)
{
}

typedef GoaCalendarIface GoaCalendarInterface;
G_DEFINE_INTERFACE (GoaCalendar, goa_calendar, G_TYPE_OBJECT);

/* ------------------------------------------------------------------------ */

/**
 * GoaCalendarProxy:
 *
 * The #GoaCalendarProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaCalendarProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaCalendarProxy.
 */

struct _GoaCalendarProxyPrivate
{
  GData *qdata;
};

static void goa_calendar_proxy_iface_init (GoaCalendarIface *iface);

G_DEFINE_TYPE_WITH_CODE (GoaCalendarProxy, goa_calendar_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CALENDAR, goa_calendar_proxy_iface_init));

static void
goa_calendar_proxy_finalize (GObject *object)
{
  GoaCalendarProxy *proxy = GOA_CALENDAR_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_calendar_proxy_parent_class)->finalize (object);
}

static void
goa_calendar_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
goa_calendar_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
goa_calendar_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_calendar_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_CALENDAR);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_CALENDAR);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_calendar_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaCalendarProxy *proxy = GOA_CALENDAR_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_calendar_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_calendar_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_calendar_proxy_init (GoaCalendarProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_CALENDAR_PROXY, GoaCalendarProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_calendar_interface_info ());
}

static void
goa_calendar_proxy_class_init (GoaCalendarProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (GoaCalendarProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_calendar_proxy_finalize;
  gobject_class->get_property = goa_calendar_proxy_get_property;
  gobject_class->set_property = goa_calendar_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_calendar_proxy_g_signal;
  proxy_class->g_properties_changed = goa_calendar_proxy_g_properties_changed;

}

static void
goa_calendar_proxy_iface_init (GoaCalendarIface *iface)
{
}

/**
 * goa_calendar_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_calendar_proxy_new_finish() to get the result of the operation.
 *
 * See goa_calendar_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_calendar_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_CALENDAR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Calendar", NULL);
}

/**
 * goa_calendar_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_calendar_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_calendar_proxy_new().
 *
 * Returns: (transfer full) (type GoaCalendarProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaCalendar *
goa_calendar_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_CALENDAR (ret);
  else
    return NULL;
}

/**
 * goa_calendar_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_calendar_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaCalendarProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaCalendar *
goa_calendar_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_CALENDAR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Calendar", NULL);
  if (ret != NULL)
    return GOA_CALENDAR (ret);
  else
    return NULL;
}


/**
 * goa_calendar_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_calendar_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_calendar_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_calendar_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_calendar_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_CALENDAR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Calendar", NULL);
}

/**
 * goa_calendar_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_calendar_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_calendar_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaCalendarProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaCalendar *
goa_calendar_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_CALENDAR (ret);
  else
    return NULL;
}

/**
 * goa_calendar_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_calendar_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_calendar_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaCalendarProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaCalendar *
goa_calendar_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_CALENDAR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Calendar", NULL);
  if (ret != NULL)
    return GOA_CALENDAR (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaCalendarSkeleton:
 *
 * The #GoaCalendarSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaCalendarSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaCalendarSkeleton.
 */

struct _GoaCalendarSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_calendar_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_CALENDAR);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_CALENDAR);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_calendar_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_calendar_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_calendar_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_calendar_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_calendar_skeleton_vtable =
{
  _goa_calendar_skeleton_handle_method_call,
  _goa_calendar_skeleton_handle_get_property,
  _goa_calendar_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
goa_calendar_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return goa_calendar_interface_info ();
}

static GDBusInterfaceVTable *
goa_calendar_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_goa_calendar_skeleton_vtable;
}

static GVariant *
goa_calendar_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_calendar_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_calendar_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_calendar_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_calendar_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Calendar", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_calendar_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_calendar_skeleton_iface_init (GoaCalendarIface *iface);
G_DEFINE_TYPE_WITH_CODE (GoaCalendarSkeleton, goa_calendar_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CALENDAR, goa_calendar_skeleton_iface_init));

static void
goa_calendar_skeleton_finalize (GObject *object)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_calendar_skeleton_parent_class)->finalize (object);
}

static void
goa_calendar_skeleton_init (GoaCalendarSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_CALENDAR_SKELETON, GoaCalendarSkeletonPrivate);
  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_calendar_skeleton_class_init (GoaCalendarSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (GoaCalendarSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_calendar_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_calendar_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_calendar_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_calendar_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_calendar_skeleton_dbus_interface_get_vtable;
}

static void
goa_calendar_skeleton_iface_init (GoaCalendarIface *iface)
{
}

/**
 * goa_calendar_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link>.
 *
 * Returns: (transfer full) (type GoaCalendarSkeleton): The skeleton object.
 */
GoaCalendar *
goa_calendar_skeleton_new (void)
{
  return GOA_CALENDAR (g_object_new (GOA_TYPE_CALENDAR_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Contacts
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaContacts
 * @title: GoaContacts
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Contacts D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Contacts ---- */

static const _ExtendedGDBusInterfaceInfo _goa_contacts_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Contacts",
    NULL,
    NULL,
    NULL,
    NULL
  },
  "contacts",
};


/**
 * goa_contacts_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_contacts_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_contacts_interface_info.parent_struct;
}

/**
 * goa_contacts_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaContacts interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_contacts_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaContacts:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link>.
 */

/**
 * GoaContactsIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link>.
 */

static void
goa_contacts_default_init (GoaContactsIface *iface)
{
}

typedef GoaContactsIface GoaContactsInterface;
G_DEFINE_INTERFACE (GoaContacts, goa_contacts, G_TYPE_OBJECT);

/* ------------------------------------------------------------------------ */

/**
 * GoaContactsProxy:
 *
 * The #GoaContactsProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaContactsProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaContactsProxy.
 */

struct _GoaContactsProxyPrivate
{
  GData *qdata;
};

static void goa_contacts_proxy_iface_init (GoaContactsIface *iface);

G_DEFINE_TYPE_WITH_CODE (GoaContactsProxy, goa_contacts_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CONTACTS, goa_contacts_proxy_iface_init));

static void
goa_contacts_proxy_finalize (GObject *object)
{
  GoaContactsProxy *proxy = GOA_CONTACTS_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_contacts_proxy_parent_class)->finalize (object);
}

static void
goa_contacts_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
goa_contacts_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
goa_contacts_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_contacts_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_CONTACTS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_CONTACTS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_contacts_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaContactsProxy *proxy = GOA_CONTACTS_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_contacts_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_contacts_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_contacts_proxy_init (GoaContactsProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_CONTACTS_PROXY, GoaContactsProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_contacts_interface_info ());
}

static void
goa_contacts_proxy_class_init (GoaContactsProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (GoaContactsProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_contacts_proxy_finalize;
  gobject_class->get_property = goa_contacts_proxy_get_property;
  gobject_class->set_property = goa_contacts_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_contacts_proxy_g_signal;
  proxy_class->g_properties_changed = goa_contacts_proxy_g_properties_changed;

}

static void
goa_contacts_proxy_iface_init (GoaContactsIface *iface)
{
}

/**
 * goa_contacts_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_contacts_proxy_new_finish() to get the result of the operation.
 *
 * See goa_contacts_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_contacts_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_CONTACTS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Contacts", NULL);
}

/**
 * goa_contacts_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_contacts_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_contacts_proxy_new().
 *
 * Returns: (transfer full) (type GoaContactsProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaContacts *
goa_contacts_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_CONTACTS (ret);
  else
    return NULL;
}

/**
 * goa_contacts_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_contacts_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaContactsProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaContacts *
goa_contacts_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_CONTACTS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Contacts", NULL);
  if (ret != NULL)
    return GOA_CONTACTS (ret);
  else
    return NULL;
}


/**
 * goa_contacts_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_contacts_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_contacts_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_contacts_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_contacts_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_CONTACTS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Contacts", NULL);
}

/**
 * goa_contacts_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_contacts_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_contacts_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaContactsProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaContacts *
goa_contacts_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_CONTACTS (ret);
  else
    return NULL;
}

/**
 * goa_contacts_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_contacts_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_contacts_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaContactsProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaContacts *
goa_contacts_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_CONTACTS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Contacts", NULL);
  if (ret != NULL)
    return GOA_CONTACTS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaContactsSkeleton:
 *
 * The #GoaContactsSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaContactsSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaContactsSkeleton.
 */

struct _GoaContactsSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_contacts_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_CONTACTS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_CONTACTS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_contacts_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_contacts_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_contacts_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_contacts_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_contacts_skeleton_vtable =
{
  _goa_contacts_skeleton_handle_method_call,
  _goa_contacts_skeleton_handle_get_property,
  _goa_contacts_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
goa_contacts_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return goa_contacts_interface_info ();
}

static GDBusInterfaceVTable *
goa_contacts_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_goa_contacts_skeleton_vtable;
}

static GVariant *
goa_contacts_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_contacts_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_contacts_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_contacts_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_contacts_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Contacts", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_contacts_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_contacts_skeleton_iface_init (GoaContactsIface *iface);
G_DEFINE_TYPE_WITH_CODE (GoaContactsSkeleton, goa_contacts_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CONTACTS, goa_contacts_skeleton_iface_init));

static void
goa_contacts_skeleton_finalize (GObject *object)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_contacts_skeleton_parent_class)->finalize (object);
}

static void
goa_contacts_skeleton_init (GoaContactsSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_CONTACTS_SKELETON, GoaContactsSkeletonPrivate);
  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_contacts_skeleton_class_init (GoaContactsSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (GoaContactsSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_contacts_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_contacts_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_contacts_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_contacts_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_contacts_skeleton_dbus_interface_get_vtable;
}

static void
goa_contacts_skeleton_iface_init (GoaContactsIface *iface)
{
}

/**
 * goa_contacts_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link>.
 *
 * Returns: (transfer full) (type GoaContactsSkeleton): The skeleton object.
 */
GoaContacts *
goa_contacts_skeleton_new (void)
{
  return GOA_CONTACTS (g_object_new (GOA_TYPE_CONTACTS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Chat
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaChat
 * @title: GoaChat
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Chat D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Chat ---- */

static const _ExtendedGDBusInterfaceInfo _goa_chat_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Chat",
    NULL,
    NULL,
    NULL,
    NULL
  },
  "chat",
};


/**
 * goa_chat_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_chat_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_chat_interface_info.parent_struct;
}

/**
 * goa_chat_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaChat interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_chat_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaChat:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link>.
 */

/**
 * GoaChatIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link>.
 */

static void
goa_chat_default_init (GoaChatIface *iface)
{
}

typedef GoaChatIface GoaChatInterface;
G_DEFINE_INTERFACE (GoaChat, goa_chat, G_TYPE_OBJECT);

/* ------------------------------------------------------------------------ */

/**
 * GoaChatProxy:
 *
 * The #GoaChatProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaChatProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaChatProxy.
 */

struct _GoaChatProxyPrivate
{
  GData *qdata;
};

static void goa_chat_proxy_iface_init (GoaChatIface *iface);

G_DEFINE_TYPE_WITH_CODE (GoaChatProxy, goa_chat_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CHAT, goa_chat_proxy_iface_init));

static void
goa_chat_proxy_finalize (GObject *object)
{
  GoaChatProxy *proxy = GOA_CHAT_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_chat_proxy_parent_class)->finalize (object);
}

static void
goa_chat_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
goa_chat_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
goa_chat_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_chat_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_CHAT);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_CHAT);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_chat_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaChatProxy *proxy = GOA_CHAT_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_chat_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_chat_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_chat_proxy_init (GoaChatProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_CHAT_PROXY, GoaChatProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_chat_interface_info ());
}

static void
goa_chat_proxy_class_init (GoaChatProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (GoaChatProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_chat_proxy_finalize;
  gobject_class->get_property = goa_chat_proxy_get_property;
  gobject_class->set_property = goa_chat_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_chat_proxy_g_signal;
  proxy_class->g_properties_changed = goa_chat_proxy_g_properties_changed;

}

static void
goa_chat_proxy_iface_init (GoaChatIface *iface)
{
}

/**
 * goa_chat_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_chat_proxy_new_finish() to get the result of the operation.
 *
 * See goa_chat_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_chat_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_CHAT_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Chat", NULL);
}

/**
 * goa_chat_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_chat_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_chat_proxy_new().
 *
 * Returns: (transfer full) (type GoaChatProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaChat *
goa_chat_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_CHAT (ret);
  else
    return NULL;
}

/**
 * goa_chat_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_chat_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaChatProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaChat *
goa_chat_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_CHAT_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Chat", NULL);
  if (ret != NULL)
    return GOA_CHAT (ret);
  else
    return NULL;
}


/**
 * goa_chat_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_chat_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_chat_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_chat_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_chat_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_CHAT_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Chat", NULL);
}

/**
 * goa_chat_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_chat_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_chat_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaChatProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaChat *
goa_chat_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_CHAT (ret);
  else
    return NULL;
}

/**
 * goa_chat_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_chat_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_chat_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaChatProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaChat *
goa_chat_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_CHAT_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Chat", NULL);
  if (ret != NULL)
    return GOA_CHAT (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaChatSkeleton:
 *
 * The #GoaChatSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaChatSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaChatSkeleton.
 */

struct _GoaChatSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_chat_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaChatSkeleton *skeleton = GOA_CHAT_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_CHAT);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_CHAT);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_chat_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaChatSkeleton *skeleton = GOA_CHAT_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_chat_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_chat_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaChatSkeleton *skeleton = GOA_CHAT_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_chat_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_chat_skeleton_vtable =
{
  _goa_chat_skeleton_handle_method_call,
  _goa_chat_skeleton_handle_get_property,
  _goa_chat_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
goa_chat_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return goa_chat_interface_info ();
}

static GDBusInterfaceVTable *
goa_chat_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_goa_chat_skeleton_vtable;
}

static GVariant *
goa_chat_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaChatSkeleton *skeleton = GOA_CHAT_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_chat_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_chat_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_chat_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_chat_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Chat", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_chat_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_chat_skeleton_iface_init (GoaChatIface *iface);
G_DEFINE_TYPE_WITH_CODE (GoaChatSkeleton, goa_chat_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CHAT, goa_chat_skeleton_iface_init));

static void
goa_chat_skeleton_finalize (GObject *object)
{
  GoaChatSkeleton *skeleton = GOA_CHAT_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_chat_skeleton_parent_class)->finalize (object);
}

static void
goa_chat_skeleton_init (GoaChatSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_CHAT_SKELETON, GoaChatSkeletonPrivate);
  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_chat_skeleton_class_init (GoaChatSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (GoaChatSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_chat_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_chat_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_chat_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_chat_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_chat_skeleton_dbus_interface_get_vtable;
}

static void
goa_chat_skeleton_iface_init (GoaChatIface *iface)
{
}

/**
 * goa_chat_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link>.
 *
 * Returns: (transfer full) (type GoaChatSkeleton): The skeleton object.
 */
GoaChat *
goa_chat_skeleton_new (void)
{
  return GOA_CHAT (g_object_new (GOA_TYPE_CHAT_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Documents
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaDocuments
 * @title: GoaDocuments
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Documents D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Documents ---- */

static const _ExtendedGDBusInterfaceInfo _goa_documents_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Documents",
    NULL,
    NULL,
    NULL,
    NULL
  },
  "documents",
};


/**
 * goa_documents_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_documents_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_documents_interface_info.parent_struct;
}

/**
 * goa_documents_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaDocuments interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_documents_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaDocuments:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link>.
 */

/**
 * GoaDocumentsIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link>.
 */

static void
goa_documents_default_init (GoaDocumentsIface *iface)
{
}

typedef GoaDocumentsIface GoaDocumentsInterface;
G_DEFINE_INTERFACE (GoaDocuments, goa_documents, G_TYPE_OBJECT);

/* ------------------------------------------------------------------------ */

/**
 * GoaDocumentsProxy:
 *
 * The #GoaDocumentsProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaDocumentsProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaDocumentsProxy.
 */

struct _GoaDocumentsProxyPrivate
{
  GData *qdata;
};

static void goa_documents_proxy_iface_init (GoaDocumentsIface *iface);

G_DEFINE_TYPE_WITH_CODE (GoaDocumentsProxy, goa_documents_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_DOCUMENTS, goa_documents_proxy_iface_init));

static void
goa_documents_proxy_finalize (GObject *object)
{
  GoaDocumentsProxy *proxy = GOA_DOCUMENTS_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_documents_proxy_parent_class)->finalize (object);
}

static void
goa_documents_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
goa_documents_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
goa_documents_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_documents_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_DOCUMENTS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_DOCUMENTS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_documents_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaDocumentsProxy *proxy = GOA_DOCUMENTS_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_documents_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_documents_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_documents_proxy_init (GoaDocumentsProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_DOCUMENTS_PROXY, GoaDocumentsProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_documents_interface_info ());
}

static void
goa_documents_proxy_class_init (GoaDocumentsProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (GoaDocumentsProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_documents_proxy_finalize;
  gobject_class->get_property = goa_documents_proxy_get_property;
  gobject_class->set_property = goa_documents_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_documents_proxy_g_signal;
  proxy_class->g_properties_changed = goa_documents_proxy_g_properties_changed;

}

static void
goa_documents_proxy_iface_init (GoaDocumentsIface *iface)
{
}

/**
 * goa_documents_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_documents_proxy_new_finish() to get the result of the operation.
 *
 * See goa_documents_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_documents_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_DOCUMENTS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Documents", NULL);
}

/**
 * goa_documents_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_documents_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_documents_proxy_new().
 *
 * Returns: (transfer full) (type GoaDocumentsProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaDocuments *
goa_documents_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_DOCUMENTS (ret);
  else
    return NULL;
}

/**
 * goa_documents_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_documents_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaDocumentsProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaDocuments *
goa_documents_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_DOCUMENTS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Documents", NULL);
  if (ret != NULL)
    return GOA_DOCUMENTS (ret);
  else
    return NULL;
}


/**
 * goa_documents_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_documents_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_documents_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_documents_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_documents_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_DOCUMENTS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Documents", NULL);
}

/**
 * goa_documents_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_documents_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_documents_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaDocumentsProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaDocuments *
goa_documents_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_DOCUMENTS (ret);
  else
    return NULL;
}

/**
 * goa_documents_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_documents_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_documents_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaDocumentsProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaDocuments *
goa_documents_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_DOCUMENTS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Documents", NULL);
  if (ret != NULL)
    return GOA_DOCUMENTS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaDocumentsSkeleton:
 *
 * The #GoaDocumentsSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaDocumentsSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaDocumentsSkeleton.
 */

struct _GoaDocumentsSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_documents_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaDocumentsSkeleton *skeleton = GOA_DOCUMENTS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_DOCUMENTS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_DOCUMENTS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_documents_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaDocumentsSkeleton *skeleton = GOA_DOCUMENTS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_documents_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_documents_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaDocumentsSkeleton *skeleton = GOA_DOCUMENTS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_documents_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_documents_skeleton_vtable =
{
  _goa_documents_skeleton_handle_method_call,
  _goa_documents_skeleton_handle_get_property,
  _goa_documents_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
goa_documents_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return goa_documents_interface_info ();
}

static GDBusInterfaceVTable *
goa_documents_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_goa_documents_skeleton_vtable;
}

static GVariant *
goa_documents_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaDocumentsSkeleton *skeleton = GOA_DOCUMENTS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_documents_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_documents_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_documents_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_documents_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Documents", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_documents_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_documents_skeleton_iface_init (GoaDocumentsIface *iface);
G_DEFINE_TYPE_WITH_CODE (GoaDocumentsSkeleton, goa_documents_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_DOCUMENTS, goa_documents_skeleton_iface_init));

static void
goa_documents_skeleton_finalize (GObject *object)
{
  GoaDocumentsSkeleton *skeleton = GOA_DOCUMENTS_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_documents_skeleton_parent_class)->finalize (object);
}

static void
goa_documents_skeleton_init (GoaDocumentsSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_DOCUMENTS_SKELETON, GoaDocumentsSkeletonPrivate);
  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_documents_skeleton_class_init (GoaDocumentsSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (GoaDocumentsSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_documents_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_documents_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_documents_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_documents_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_documents_skeleton_dbus_interface_get_vtable;
}

static void
goa_documents_skeleton_iface_init (GoaDocumentsIface *iface)
{
}

/**
 * goa_documents_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link>.
 *
 * Returns: (transfer full) (type GoaDocumentsSkeleton): The skeleton object.
 */
GoaDocuments *
goa_documents_skeleton_new (void)
{
  return GOA_DOCUMENTS (g_object_new (GOA_TYPE_DOCUMENTS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Exchange
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaExchange
 * @title: GoaExchange
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Exchange D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Exchange ---- */

static const _ExtendedGDBusPropertyInfo _goa_exchange_property_info_host =
{
  {
    -1,
    (gchar *) "Host",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "host",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _goa_exchange_property_info_pointers[] =
{
  &_goa_exchange_property_info_host,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_exchange_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Exchange",
    NULL,
    NULL,
    (GDBusPropertyInfo **) &_goa_exchange_property_info_pointers,
    NULL
  },
  "exchange",
};


/**
 * goa_exchange_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Since: 3.6.0
 */
GDBusInterfaceInfo *
goa_exchange_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_exchange_interface_info.parent_struct;
}

/**
 * goa_exchange_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaExchange interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Since: 3.6.0
 */
guint
goa_exchange_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "host");
  return property_id_begin - 1;
}



/**
 * GoaExchange:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link>.
 *
 * Since: 3.6.0
 */

/**
 * GoaExchangeIface:
 * @parent_iface: The parent interface.
 * @get_host: Getter for the #GoaExchange:host property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link>.
 *
 * Since: 3.6.0
 */

static void
goa_exchange_default_init (GoaExchangeIface *iface)
{
  /* GObject properties for D-Bus properties: */
  /**
   * GoaExchange:host:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Exchange.Host">"Host"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.6.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("host", "Host", "Host", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef GoaExchangeIface GoaExchangeInterface;
G_DEFINE_INTERFACE (GoaExchange, goa_exchange, G_TYPE_OBJECT);

/**
 * goa_exchange_get_host: (skip)
 * @object: A #GoaExchange.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Exchange.Host">"Host"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_exchange_dup_host() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 *
 * Since: 3.6.0
 */
const gchar *
goa_exchange_get_host (GoaExchange *object)
{
  return GOA_EXCHANGE_GET_IFACE (object)->get_host (object);
}

/**
 * goa_exchange_dup_host: (skip)
 * @object: A #GoaExchange.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Exchange.Host">"Host"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 *
 * Since: 3.6.0
 */
gchar *
goa_exchange_dup_host (GoaExchange *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "host", &value, NULL);
  return value;
}

/**
 * goa_exchange_set_host: (skip)
 * @object: A #GoaExchange.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Exchange.Host">"Host"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.6.0
 */
void
goa_exchange_set_host (GoaExchange *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "host", value, NULL);
}

/* ------------------------------------------------------------------------ */

/**
 * GoaExchangeProxy:
 *
 * The #GoaExchangeProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.6.0
 */

/**
 * GoaExchangeProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaExchangeProxy.
 *
 * Since: 3.6.0
 */

struct _GoaExchangeProxyPrivate
{
  GData *qdata;
};

static void goa_exchange_proxy_iface_init (GoaExchangeIface *iface);

G_DEFINE_TYPE_WITH_CODE (GoaExchangeProxy, goa_exchange_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_EXCHANGE, goa_exchange_proxy_iface_init));

static void
goa_exchange_proxy_finalize (GObject *object)
{
  GoaExchangeProxy *proxy = GOA_EXCHANGE_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_exchange_proxy_parent_class)->finalize (object);
}

static void
goa_exchange_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _goa_exchange_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
goa_exchange_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface org.gnome.OnlineAccounts.Exchange: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
goa_exchange_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _goa_exchange_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.gnome.OnlineAccounts.Exchange", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) goa_exchange_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
goa_exchange_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_exchange_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_EXCHANGE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_EXCHANGE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_exchange_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaExchangeProxy *proxy = GOA_EXCHANGE_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_exchange_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_exchange_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
goa_exchange_proxy_get_host (GoaExchange *object)
{
  GoaExchangeProxy *proxy = GOA_EXCHANGE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Host");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
goa_exchange_proxy_init (GoaExchangeProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_EXCHANGE_PROXY, GoaExchangeProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_exchange_interface_info ());
}

static void
goa_exchange_proxy_class_init (GoaExchangeProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (GoaExchangeProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_exchange_proxy_finalize;
  gobject_class->get_property = goa_exchange_proxy_get_property;
  gobject_class->set_property = goa_exchange_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_exchange_proxy_g_signal;
  proxy_class->g_properties_changed = goa_exchange_proxy_g_properties_changed;


  goa_exchange_override_properties (gobject_class, 1);
}

static void
goa_exchange_proxy_iface_init (GoaExchangeIface *iface)
{
  iface->get_host = goa_exchange_proxy_get_host;
}

/**
 * goa_exchange_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_exchange_proxy_new_finish() to get the result of the operation.
 *
 * See goa_exchange_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.6.0
 */
void
goa_exchange_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_EXCHANGE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Exchange", NULL);
}

/**
 * goa_exchange_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_exchange_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_exchange_proxy_new().
 *
 * Returns: (transfer full) (type GoaExchangeProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaExchange *
goa_exchange_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_EXCHANGE (ret);
  else
    return NULL;
}

/**
 * goa_exchange_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_exchange_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaExchangeProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaExchange *
goa_exchange_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_EXCHANGE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Exchange", NULL);
  if (ret != NULL)
    return GOA_EXCHANGE (ret);
  else
    return NULL;
}


/**
 * goa_exchange_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_exchange_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_exchange_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_exchange_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.6.0
 */
void
goa_exchange_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_EXCHANGE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Exchange", NULL);
}

/**
 * goa_exchange_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_exchange_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_exchange_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaExchangeProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaExchange *
goa_exchange_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_EXCHANGE (ret);
  else
    return NULL;
}

/**
 * goa_exchange_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_exchange_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_exchange_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaExchangeProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaExchange *
goa_exchange_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_EXCHANGE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Exchange", NULL);
  if (ret != NULL)
    return GOA_EXCHANGE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaExchangeSkeleton:
 *
 * The #GoaExchangeSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.6.0
 */

/**
 * GoaExchangeSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaExchangeSkeleton.
 *
 * Since: 3.6.0
 */

struct _GoaExchangeSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_exchange_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_EXCHANGE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_EXCHANGE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_exchange_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_exchange_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_exchange_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_exchange_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_exchange_skeleton_vtable =
{
  _goa_exchange_skeleton_handle_method_call,
  _goa_exchange_skeleton_handle_get_property,
  _goa_exchange_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
goa_exchange_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return goa_exchange_interface_info ();
}

static GDBusInterfaceVTable *
goa_exchange_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_goa_exchange_skeleton_vtable;
}

static GVariant *
goa_exchange_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_exchange_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_exchange_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_exchange_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_exchange_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Exchange", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _goa_exchange_emit_changed (gpointer user_data);

static void
goa_exchange_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _goa_exchange_emit_changed (skeleton);
}

static void goa_exchange_skeleton_iface_init (GoaExchangeIface *iface);
G_DEFINE_TYPE_WITH_CODE (GoaExchangeSkeleton, goa_exchange_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_EXCHANGE, goa_exchange_skeleton_iface_init));

static void
goa_exchange_skeleton_finalize (GObject *object)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (object);
  guint n;
  for (n = 0; n < 1; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_exchange_skeleton_parent_class)->finalize (object);
}

static void
goa_exchange_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_goa_exchange_emit_changed (gpointer user_data)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.gnome.OnlineAccounts.Exchange",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_goa_exchange_schedule_emit_changed (GoaExchangeSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
goa_exchange_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _goa_exchange_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
goa_exchange_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _goa_exchange_schedule_emit_changed (skeleton, _goa_exchange_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
goa_exchange_skeleton_init (GoaExchangeSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_EXCHANGE_SKELETON, GoaExchangeSkeletonPrivate);
  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 1);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
}

static const gchar *
goa_exchange_skeleton_get_host (GoaExchange *object)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
goa_exchange_skeleton_class_init (GoaExchangeSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (GoaExchangeSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_exchange_skeleton_finalize;
  gobject_class->get_property = goa_exchange_skeleton_get_property;
  gobject_class->set_property = goa_exchange_skeleton_set_property;
  gobject_class->notify       = goa_exchange_skeleton_notify;


  goa_exchange_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_exchange_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_exchange_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_exchange_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_exchange_skeleton_dbus_interface_get_vtable;
}

static void
goa_exchange_skeleton_iface_init (GoaExchangeIface *iface)
{
  iface->get_host = goa_exchange_skeleton_get_host;
}

/**
 * goa_exchange_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link>.
 *
 * Returns: (transfer full) (type GoaExchangeSkeleton): The skeleton object.
 *
 * Since: 3.6.0
 */
GoaExchange *
goa_exchange_skeleton_new (void)
{
  return GOA_EXCHANGE (g_object_new (GOA_TYPE_EXCHANGE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Ticketing
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaTicketing
 * @title: GoaTicketing
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Ticketing D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Ticketing ---- */

static const _ExtendedGDBusMethodInfo _goa_ticketing_method_info_get_ticket =
{
  {
    -1,
    (gchar *) "GetTicket",
    NULL,
    NULL,
    NULL
  },
  "handle-get-ticket",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _goa_ticketing_method_info_pointers[] =
{
  &_goa_ticketing_method_info_get_ticket,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_ticketing_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Ticketing",
    (GDBusMethodInfo **) &_goa_ticketing_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "ticketing",
};


/**
 * goa_ticketing_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_ticketing_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_ticketing_interface_info.parent_struct;
}

/**
 * goa_ticketing_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaTicketing interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_ticketing_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaTicketing:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link>.
 */

/**
 * GoaTicketingIface:
 * @parent_iface: The parent interface.
 * @handle_get_ticket: Handler for the #GoaTicketing::handle-get-ticket signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link>.
 */

static void
goa_ticketing_default_init (GoaTicketingIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * GoaTicketing::handle-get-ticket:
   * @object: A #GoaTicketing.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Ticketing.GetTicket">GetTicket()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call goa_ticketing_complete_get_ticket() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-ticket",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (GoaTicketingIface, handle_get_ticket),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

}

typedef GoaTicketingIface GoaTicketingInterface;
G_DEFINE_INTERFACE (GoaTicketing, goa_ticketing, G_TYPE_OBJECT);

/**
 * goa_ticketing_call_get_ticket:
 * @proxy: A #GoaTicketingProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Ticketing.GetTicket">GetTicket()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_ticketing_call_get_ticket_finish() to get the result of the operation.
 *
 * See goa_ticketing_call_get_ticket_sync() for the synchronous, blocking version of this method.
 */
void
goa_ticketing_call_get_ticket (
    GoaTicketing *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GetTicket",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * goa_ticketing_call_get_ticket_finish:
 * @proxy: A #GoaTicketingProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_ticketing_call_get_ticket().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with goa_ticketing_call_get_ticket().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
goa_ticketing_call_get_ticket_finish (
    GoaTicketing *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_ticketing_call_get_ticket_sync:
 * @proxy: A #GoaTicketingProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Ticketing.GetTicket">GetTicket()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See goa_ticketing_call_get_ticket() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
goa_ticketing_call_get_ticket_sync (
    GoaTicketing *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GetTicket",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_ticketing_complete_get_ticket:
 * @object: A #GoaTicketing.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Ticketing.GetTicket">GetTicket()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
goa_ticketing_complete_get_ticket (
    GoaTicketing *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * GoaTicketingProxy:
 *
 * The #GoaTicketingProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaTicketingProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaTicketingProxy.
 */

struct _GoaTicketingProxyPrivate
{
  GData *qdata;
};

static void goa_ticketing_proxy_iface_init (GoaTicketingIface *iface);

G_DEFINE_TYPE_WITH_CODE (GoaTicketingProxy, goa_ticketing_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_TICKETING, goa_ticketing_proxy_iface_init));

static void
goa_ticketing_proxy_finalize (GObject *object)
{
  GoaTicketingProxy *proxy = GOA_TICKETING_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_ticketing_proxy_parent_class)->finalize (object);
}

static void
goa_ticketing_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
goa_ticketing_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
goa_ticketing_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_ticketing_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_TICKETING);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_TICKETING);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_ticketing_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaTicketingProxy *proxy = GOA_TICKETING_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_ticketing_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_ticketing_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_ticketing_proxy_init (GoaTicketingProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_TICKETING_PROXY, GoaTicketingProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_ticketing_interface_info ());
}

static void
goa_ticketing_proxy_class_init (GoaTicketingProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (GoaTicketingProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_ticketing_proxy_finalize;
  gobject_class->get_property = goa_ticketing_proxy_get_property;
  gobject_class->set_property = goa_ticketing_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_ticketing_proxy_g_signal;
  proxy_class->g_properties_changed = goa_ticketing_proxy_g_properties_changed;

}

static void
goa_ticketing_proxy_iface_init (GoaTicketingIface *iface)
{
}

/**
 * goa_ticketing_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_ticketing_proxy_new_finish() to get the result of the operation.
 *
 * See goa_ticketing_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_ticketing_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_TICKETING_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Ticketing", NULL);
}

/**
 * goa_ticketing_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_ticketing_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_ticketing_proxy_new().
 *
 * Returns: (transfer full) (type GoaTicketingProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaTicketing *
goa_ticketing_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_TICKETING (ret);
  else
    return NULL;
}

/**
 * goa_ticketing_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_ticketing_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaTicketingProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaTicketing *
goa_ticketing_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_TICKETING_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Ticketing", NULL);
  if (ret != NULL)
    return GOA_TICKETING (ret);
  else
    return NULL;
}


/**
 * goa_ticketing_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_ticketing_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_ticketing_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_ticketing_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_ticketing_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_TICKETING_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Ticketing", NULL);
}

/**
 * goa_ticketing_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_ticketing_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_ticketing_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaTicketingProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaTicketing *
goa_ticketing_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_TICKETING (ret);
  else
    return NULL;
}

/**
 * goa_ticketing_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_ticketing_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_ticketing_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaTicketingProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaTicketing *
goa_ticketing_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_TICKETING_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Ticketing", NULL);
  if (ret != NULL)
    return GOA_TICKETING (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaTicketingSkeleton:
 *
 * The #GoaTicketingSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaTicketingSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaTicketingSkeleton.
 */

struct _GoaTicketingSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_ticketing_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_TICKETING);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_TICKETING);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_ticketing_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_ticketing_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_ticketing_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_ticketing_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_ticketing_skeleton_vtable =
{
  _goa_ticketing_skeleton_handle_method_call,
  _goa_ticketing_skeleton_handle_get_property,
  _goa_ticketing_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
goa_ticketing_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return goa_ticketing_interface_info ();
}

static GDBusInterfaceVTable *
goa_ticketing_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_goa_ticketing_skeleton_vtable;
}

static GVariant *
goa_ticketing_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_ticketing_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_ticketing_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_ticketing_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_ticketing_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Ticketing", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_ticketing_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_ticketing_skeleton_iface_init (GoaTicketingIface *iface);
G_DEFINE_TYPE_WITH_CODE (GoaTicketingSkeleton, goa_ticketing_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_TICKETING, goa_ticketing_skeleton_iface_init));

static void
goa_ticketing_skeleton_finalize (GObject *object)
{
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_ticketing_skeleton_parent_class)->finalize (object);
}

static void
goa_ticketing_skeleton_init (GoaTicketingSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_TICKETING_SKELETON, GoaTicketingSkeletonPrivate);
  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_ticketing_skeleton_class_init (GoaTicketingSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (GoaTicketingSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_ticketing_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_ticketing_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_ticketing_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_ticketing_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_ticketing_skeleton_dbus_interface_get_vtable;
}

static void
goa_ticketing_skeleton_iface_init (GoaTicketingIface *iface)
{
}

/**
 * goa_ticketing_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link>.
 *
 * Returns: (transfer full) (type GoaTicketingSkeleton): The skeleton object.
 */
GoaTicketing *
goa_ticketing_skeleton_new (void)
{
  return GOA_TICKETING (g_object_new (GOA_TYPE_TICKETING_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for Object, ObjectProxy and ObjectSkeleton
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaObject
 * @title: GoaObject
 * @short_description: Specialized GDBusObject types
 *
 * This section contains the #GoaObject, #GoaObjectProxy, and #GoaObjectSkeleton types which make it easier to work with objects implementing generated types for D-Bus interfaces.
 */

/**
 * GoaObject:
 *
 * The #GoaObject type is a specialized container of interfaces.
 */

/**
 * GoaObjectIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the #GoaObject interface.
 */

static void
goa_object_default_init (GoaObjectIface *iface)
{
  /**
   * GoaObject:account:
   *
   * The #GoaAccount instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("account", "account", "account", GOA_TYPE_ACCOUNT, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:oauth2-based:
   *
   * The #GoaOAuth2Based instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("oauth2-based", "oauth2-based", "oauth2-based", GOA_TYPE_OAUTH2_BASED, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:oauth-based:
   *
   * The #GoaOAuthBased instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("oauth-based", "oauth-based", "oauth-based", GOA_TYPE_OAUTH_BASED, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:password-based:
   *
   * The #GoaPasswordBased instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Since: 3.6.0
   */
  g_object_interface_install_property (iface, g_param_spec_object ("password-based", "password-based", "password-based", GOA_TYPE_PASSWORD_BASED, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:manager:
   *
   * The #GoaManager instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("manager", "manager", "manager", GOA_TYPE_MANAGER, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:mail:
   *
   * The #GoaMail instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("mail", "mail", "mail", GOA_TYPE_MAIL, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:calendar:
   *
   * The #GoaCalendar instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("calendar", "calendar", "calendar", GOA_TYPE_CALENDAR, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:contacts:
   *
   * The #GoaContacts instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("contacts", "contacts", "contacts", GOA_TYPE_CONTACTS, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:chat:
   *
   * The #GoaChat instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("chat", "chat", "chat", GOA_TYPE_CHAT, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:documents:
   *
   * The #GoaDocuments instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("documents", "documents", "documents", GOA_TYPE_DOCUMENTS, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:exchange:
   *
   * The #GoaExchange instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Since: 3.6.0
   */
  g_object_interface_install_property (iface, g_param_spec_object ("exchange", "exchange", "exchange", GOA_TYPE_EXCHANGE, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:ticketing:
   *
   * The #GoaTicketing instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("ticketing", "ticketing", "ticketing", GOA_TYPE_TICKETING, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

}

typedef GoaObjectIface GoaObjectInterface;
G_DEFINE_INTERFACE_WITH_CODE (GoaObject, goa_object, G_TYPE_OBJECT, g_type_interface_add_prerequisite (g_define_type_id, G_TYPE_DBUS_OBJECT));

/**
 * goa_object_get_account:
 * @object: A #GoaObject.
 *
 * Gets the #GoaAccount instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link> on @object, if any.
 *
 * Returns: (transfer full): A #GoaAccount that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaAccount *goa_object_get_account (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Account");
  if (ret == NULL)
    return NULL;
  return GOA_ACCOUNT (ret);
}

/**
 * goa_object_get_oauth2_based:
 * @object: A #GoaObject.
 *
 * Gets the #GoaOAuth2Based instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link> on @object, if any.
 *
 * Returns: (transfer full): A #GoaOAuth2Based that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaOAuth2Based *goa_object_get_oauth2_based (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuth2Based");
  if (ret == NULL)
    return NULL;
  return GOA_OAUTH2_BASED (ret);
}

/**
 * goa_object_get_oauth_based:
 * @object: A #GoaObject.
 *
 * Gets the #GoaOAuthBased instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link> on @object, if any.
 *
 * Returns: (transfer full): A #GoaOAuthBased that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaOAuthBased *goa_object_get_oauth_based (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuthBased");
  if (ret == NULL)
    return NULL;
  return GOA_OAUTH_BASED (ret);
}

/**
 * goa_object_get_password_based:
 * @object: A #GoaObject.
 *
 * Gets the #GoaPasswordBased instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link> on @object, if any.
 *
 * Returns: (transfer full): A #GoaPasswordBased that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Since: 3.6.0
 */
GoaPasswordBased *goa_object_get_password_based (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.PasswordBased");
  if (ret == NULL)
    return NULL;
  return GOA_PASSWORD_BASED (ret);
}

/**
 * goa_object_get_manager:
 * @object: A #GoaObject.
 *
 * Gets the #GoaManager instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link> on @object, if any.
 *
 * Returns: (transfer full): A #GoaManager that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaManager *goa_object_get_manager (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Manager");
  if (ret == NULL)
    return NULL;
  return GOA_MANAGER (ret);
}

/**
 * goa_object_get_mail:
 * @object: A #GoaObject.
 *
 * Gets the #GoaMail instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link> on @object, if any.
 *
 * Returns: (transfer full): A #GoaMail that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaMail *goa_object_get_mail (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Mail");
  if (ret == NULL)
    return NULL;
  return GOA_MAIL (ret);
}

/**
 * goa_object_get_calendar:
 * @object: A #GoaObject.
 *
 * Gets the #GoaCalendar instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link> on @object, if any.
 *
 * Returns: (transfer full): A #GoaCalendar that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaCalendar *goa_object_get_calendar (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Calendar");
  if (ret == NULL)
    return NULL;
  return GOA_CALENDAR (ret);
}

/**
 * goa_object_get_contacts:
 * @object: A #GoaObject.
 *
 * Gets the #GoaContacts instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link> on @object, if any.
 *
 * Returns: (transfer full): A #GoaContacts that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaContacts *goa_object_get_contacts (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Contacts");
  if (ret == NULL)
    return NULL;
  return GOA_CONTACTS (ret);
}

/**
 * goa_object_get_chat:
 * @object: A #GoaObject.
 *
 * Gets the #GoaChat instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link> on @object, if any.
 *
 * Returns: (transfer full): A #GoaChat that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaChat *goa_object_get_chat (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Chat");
  if (ret == NULL)
    return NULL;
  return GOA_CHAT (ret);
}

/**
 * goa_object_get_documents:
 * @object: A #GoaObject.
 *
 * Gets the #GoaDocuments instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link> on @object, if any.
 *
 * Returns: (transfer full): A #GoaDocuments that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaDocuments *goa_object_get_documents (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Documents");
  if (ret == NULL)
    return NULL;
  return GOA_DOCUMENTS (ret);
}

/**
 * goa_object_get_exchange:
 * @object: A #GoaObject.
 *
 * Gets the #GoaExchange instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link> on @object, if any.
 *
 * Returns: (transfer full): A #GoaExchange that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Since: 3.6.0
 */
GoaExchange *goa_object_get_exchange (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Exchange");
  if (ret == NULL)
    return NULL;
  return GOA_EXCHANGE (ret);
}

/**
 * goa_object_get_ticketing:
 * @object: A #GoaObject.
 *
 * Gets the #GoaTicketing instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link> on @object, if any.
 *
 * Returns: (transfer full): A #GoaTicketing that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaTicketing *goa_object_get_ticketing (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Ticketing");
  if (ret == NULL)
    return NULL;
  return GOA_TICKETING (ret);
}


/**
 * goa_object_peek_account: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_account() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #GoaAccount or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaAccount *goa_object_peek_account (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Account");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_ACCOUNT (ret);
}

/**
 * goa_object_peek_oauth2_based: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_oauth2_based() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #GoaOAuth2Based or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaOAuth2Based *goa_object_peek_oauth2_based (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuth2Based");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_OAUTH2_BASED (ret);
}

/**
 * goa_object_peek_oauth_based: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_oauth_based() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #GoaOAuthBased or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaOAuthBased *goa_object_peek_oauth_based (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuthBased");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_OAUTH_BASED (ret);
}

/**
 * goa_object_peek_password_based: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_password_based() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #GoaPasswordBased or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Since: 3.6.0
 */
GoaPasswordBased *goa_object_peek_password_based (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.PasswordBased");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_PASSWORD_BASED (ret);
}

/**
 * goa_object_peek_manager: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_manager() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #GoaManager or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaManager *goa_object_peek_manager (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Manager");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_MANAGER (ret);
}

/**
 * goa_object_peek_mail: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_mail() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #GoaMail or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaMail *goa_object_peek_mail (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Mail");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_MAIL (ret);
}

/**
 * goa_object_peek_calendar: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_calendar() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #GoaCalendar or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaCalendar *goa_object_peek_calendar (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Calendar");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_CALENDAR (ret);
}

/**
 * goa_object_peek_contacts: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_contacts() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #GoaContacts or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaContacts *goa_object_peek_contacts (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Contacts");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_CONTACTS (ret);
}

/**
 * goa_object_peek_chat: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_chat() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #GoaChat or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaChat *goa_object_peek_chat (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Chat");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_CHAT (ret);
}

/**
 * goa_object_peek_documents: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_documents() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #GoaDocuments or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaDocuments *goa_object_peek_documents (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Documents");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_DOCUMENTS (ret);
}

/**
 * goa_object_peek_exchange: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_exchange() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #GoaExchange or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Since: 3.6.0
 */
GoaExchange *goa_object_peek_exchange (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Exchange");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_EXCHANGE (ret);
}

/**
 * goa_object_peek_ticketing: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_ticketing() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #GoaTicketing or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaTicketing *goa_object_peek_ticketing (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Ticketing");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_TICKETING (ret);
}


static void
goa_object_notify (GDBusObject *object, GDBusInterface *interface)
{
  g_object_notify (G_OBJECT (object), ((_ExtendedGDBusInterfaceInfo *) g_dbus_interface_get_info (interface))->hyphen_name);
}

/**
 * GoaObjectProxy:
 *
 * The #GoaObjectProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaObjectProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaObjectProxy.
 */

static void
goa_object_proxy__goa_object_iface_init (GoaObjectIface *iface)
{
}

static void
goa_object_proxy__g_dbus_object_iface_init (GDBusObjectIface *iface)
{
  iface->interface_added = goa_object_notify;
  iface->interface_removed = goa_object_notify;
}


G_DEFINE_TYPE_WITH_CODE (GoaObjectProxy, goa_object_proxy, G_TYPE_DBUS_OBJECT_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OBJECT, goa_object_proxy__goa_object_iface_init)
                         G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_OBJECT, goa_object_proxy__g_dbus_object_iface_init));

static void
goa_object_proxy_init (GoaObjectProxy *object)
{
}

static void
goa_object_proxy_set_property (GObject      *gobject,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
}

static void
goa_object_proxy_get_property (GObject      *gobject,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  GoaObjectProxy *object = GOA_OBJECT_PROXY (gobject);
  GDBusInterface *interface;

  switch (prop_id)
    {
    case 1:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Account");
      g_value_take_object (value, interface);
      break;

    case 2:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuth2Based");
      g_value_take_object (value, interface);
      break;

    case 3:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuthBased");
      g_value_take_object (value, interface);
      break;

    case 4:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.PasswordBased");
      g_value_take_object (value, interface);
      break;

    case 5:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Manager");
      g_value_take_object (value, interface);
      break;

    case 6:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Mail");
      g_value_take_object (value, interface);
      break;

    case 7:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Calendar");
      g_value_take_object (value, interface);
      break;

    case 8:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Contacts");
      g_value_take_object (value, interface);
      break;

    case 9:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Chat");
      g_value_take_object (value, interface);
      break;

    case 10:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Documents");
      g_value_take_object (value, interface);
      break;

    case 11:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Exchange");
      g_value_take_object (value, interface);
      break;

    case 12:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Ticketing");
      g_value_take_object (value, interface);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
      break;
  }
}

static void
goa_object_proxy_class_init (GoaObjectProxyClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  gobject_class->set_property = goa_object_proxy_set_property;
  gobject_class->get_property = goa_object_proxy_get_property;

  g_object_class_override_property (gobject_class, 1, "account");
  g_object_class_override_property (gobject_class, 2, "oauth2-based");
  g_object_class_override_property (gobject_class, 3, "oauth-based");
  g_object_class_override_property (gobject_class, 4, "password-based");
  g_object_class_override_property (gobject_class, 5, "manager");
  g_object_class_override_property (gobject_class, 6, "mail");
  g_object_class_override_property (gobject_class, 7, "calendar");
  g_object_class_override_property (gobject_class, 8, "contacts");
  g_object_class_override_property (gobject_class, 9, "chat");
  g_object_class_override_property (gobject_class, 10, "documents");
  g_object_class_override_property (gobject_class, 11, "exchange");
  g_object_class_override_property (gobject_class, 12, "ticketing");
}

/**
 * goa_object_proxy_new:
 * @connection: A #GDBusConnection.
 * @object_path: An object path.
 *
 * Creates a new proxy object.
 *
 * Returns: (transfer full): The proxy object.
 */
GoaObjectProxy *
goa_object_proxy_new (GDBusConnection *connection,
  const gchar *object_path)
{
  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);
  g_return_val_if_fail (g_variant_is_object_path (object_path), NULL);
  return GOA_OBJECT_PROXY (g_object_new (GOA_TYPE_OBJECT_PROXY, "g-connection", connection, "g-object-path", object_path, NULL));
}

/**
 * GoaObjectSkeleton:
 *
 * The #GoaObjectSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaObjectSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaObjectSkeleton.
 */

static void
goa_object_skeleton__goa_object_iface_init (GoaObjectIface *iface)
{
}


static void
goa_object_skeleton__g_dbus_object_iface_init (GDBusObjectIface *iface)
{
  iface->interface_added = goa_object_notify;
  iface->interface_removed = goa_object_notify;
}

G_DEFINE_TYPE_WITH_CODE (GoaObjectSkeleton, goa_object_skeleton, G_TYPE_DBUS_OBJECT_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OBJECT, goa_object_skeleton__goa_object_iface_init)
                         G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_OBJECT, goa_object_skeleton__g_dbus_object_iface_init));

static void
goa_object_skeleton_init (GoaObjectSkeleton *object)
{
}

static void
goa_object_skeleton_set_property (GObject      *gobject,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  GoaObjectSkeleton *object = GOA_OBJECT_SKELETON (gobject);
  GDBusInterfaceSkeleton *interface;

  switch (prop_id)
    {
    case 1:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_ACCOUNT (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Account");
        }
      break;

    case 2:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_OAUTH2_BASED (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.OAuth2Based");
        }
      break;

    case 3:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_OAUTH_BASED (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.OAuthBased");
        }
      break;

    case 4:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_PASSWORD_BASED (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.PasswordBased");
        }
      break;

    case 5:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_MANAGER (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Manager");
        }
      break;

    case 6:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_MAIL (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Mail");
        }
      break;

    case 7:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_CALENDAR (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Calendar");
        }
      break;

    case 8:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_CONTACTS (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Contacts");
        }
      break;

    case 9:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_CHAT (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Chat");
        }
      break;

    case 10:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_DOCUMENTS (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Documents");
        }
      break;

    case 11:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_EXCHANGE (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Exchange");
        }
      break;

    case 12:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_TICKETING (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Ticketing");
        }
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
      break;
  }
}

static void
goa_object_skeleton_get_property (GObject      *gobject,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  GoaObjectSkeleton *object = GOA_OBJECT_SKELETON (gobject);
  GDBusInterface *interface;

  switch (prop_id)
    {
    case 1:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Account");
      g_value_take_object (value, interface);
      break;

    case 2:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuth2Based");
      g_value_take_object (value, interface);
      break;

    case 3:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuthBased");
      g_value_take_object (value, interface);
      break;

    case 4:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.PasswordBased");
      g_value_take_object (value, interface);
      break;

    case 5:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Manager");
      g_value_take_object (value, interface);
      break;

    case 6:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Mail");
      g_value_take_object (value, interface);
      break;

    case 7:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Calendar");
      g_value_take_object (value, interface);
      break;

    case 8:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Contacts");
      g_value_take_object (value, interface);
      break;

    case 9:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Chat");
      g_value_take_object (value, interface);
      break;

    case 10:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Documents");
      g_value_take_object (value, interface);
      break;

    case 11:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Exchange");
      g_value_take_object (value, interface);
      break;

    case 12:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Ticketing");
      g_value_take_object (value, interface);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
      break;
  }
}

static void
goa_object_skeleton_class_init (GoaObjectSkeletonClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  gobject_class->set_property = goa_object_skeleton_set_property;
  gobject_class->get_property = goa_object_skeleton_get_property;

  g_object_class_override_property (gobject_class, 1, "account");
  g_object_class_override_property (gobject_class, 2, "oauth2-based");
  g_object_class_override_property (gobject_class, 3, "oauth-based");
  g_object_class_override_property (gobject_class, 4, "password-based");
  g_object_class_override_property (gobject_class, 5, "manager");
  g_object_class_override_property (gobject_class, 6, "mail");
  g_object_class_override_property (gobject_class, 7, "calendar");
  g_object_class_override_property (gobject_class, 8, "contacts");
  g_object_class_override_property (gobject_class, 9, "chat");
  g_object_class_override_property (gobject_class, 10, "documents");
  g_object_class_override_property (gobject_class, 11, "exchange");
  g_object_class_override_property (gobject_class, 12, "ticketing");
}

/**
 * goa_object_skeleton_new:
 * @object_path: An object path.
 *
 * Creates a new skeleton object.
 *
 * Returns: (transfer full): The skeleton object.
 */
GoaObjectSkeleton *
goa_object_skeleton_new (const gchar *object_path)
{
  g_return_val_if_fail (g_variant_is_object_path (object_path), NULL);
  return GOA_OBJECT_SKELETON (g_object_new (GOA_TYPE_OBJECT_SKELETON, "g-object-path", object_path, NULL));
}

/**
 * goa_object_skeleton_set_account:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (allow-none): A #GoaAccount or %NULL to clear the interface.
 *
 * Sets the #GoaAccount instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link> on @object.
 */
void goa_object_skeleton_set_account (GoaObjectSkeleton *object, GoaAccount *interface_)
{
  g_object_set (G_OBJECT (object), "account", interface_, NULL);
}

/**
 * goa_object_skeleton_set_oauth2_based:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (allow-none): A #GoaOAuth2Based or %NULL to clear the interface.
 *
 * Sets the #GoaOAuth2Based instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link> on @object.
 */
void goa_object_skeleton_set_oauth2_based (GoaObjectSkeleton *object, GoaOAuth2Based *interface_)
{
  g_object_set (G_OBJECT (object), "oauth2-based", interface_, NULL);
}

/**
 * goa_object_skeleton_set_oauth_based:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (allow-none): A #GoaOAuthBased or %NULL to clear the interface.
 *
 * Sets the #GoaOAuthBased instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link> on @object.
 */
void goa_object_skeleton_set_oauth_based (GoaObjectSkeleton *object, GoaOAuthBased *interface_)
{
  g_object_set (G_OBJECT (object), "oauth-based", interface_, NULL);
}

/**
 * goa_object_skeleton_set_password_based:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (allow-none): A #GoaPasswordBased or %NULL to clear the interface.
 *
 * Sets the #GoaPasswordBased instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link> on @object.
 *
 * Since: 3.6.0
 */
void goa_object_skeleton_set_password_based (GoaObjectSkeleton *object, GoaPasswordBased *interface_)
{
  g_object_set (G_OBJECT (object), "password-based", interface_, NULL);
}

/**
 * goa_object_skeleton_set_manager:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (allow-none): A #GoaManager or %NULL to clear the interface.
 *
 * Sets the #GoaManager instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link> on @object.
 */
void goa_object_skeleton_set_manager (GoaObjectSkeleton *object, GoaManager *interface_)
{
  g_object_set (G_OBJECT (object), "manager", interface_, NULL);
}

/**
 * goa_object_skeleton_set_mail:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (allow-none): A #GoaMail or %NULL to clear the interface.
 *
 * Sets the #GoaMail instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link> on @object.
 */
void goa_object_skeleton_set_mail (GoaObjectSkeleton *object, GoaMail *interface_)
{
  g_object_set (G_OBJECT (object), "mail", interface_, NULL);
}

/**
 * goa_object_skeleton_set_calendar:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (allow-none): A #GoaCalendar or %NULL to clear the interface.
 *
 * Sets the #GoaCalendar instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link> on @object.
 */
void goa_object_skeleton_set_calendar (GoaObjectSkeleton *object, GoaCalendar *interface_)
{
  g_object_set (G_OBJECT (object), "calendar", interface_, NULL);
}

/**
 * goa_object_skeleton_set_contacts:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (allow-none): A #GoaContacts or %NULL to clear the interface.
 *
 * Sets the #GoaContacts instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link> on @object.
 */
void goa_object_skeleton_set_contacts (GoaObjectSkeleton *object, GoaContacts *interface_)
{
  g_object_set (G_OBJECT (object), "contacts", interface_, NULL);
}

/**
 * goa_object_skeleton_set_chat:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (allow-none): A #GoaChat or %NULL to clear the interface.
 *
 * Sets the #GoaChat instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link> on @object.
 */
void goa_object_skeleton_set_chat (GoaObjectSkeleton *object, GoaChat *interface_)
{
  g_object_set (G_OBJECT (object), "chat", interface_, NULL);
}

/**
 * goa_object_skeleton_set_documents:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (allow-none): A #GoaDocuments or %NULL to clear the interface.
 *
 * Sets the #GoaDocuments instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link> on @object.
 */
void goa_object_skeleton_set_documents (GoaObjectSkeleton *object, GoaDocuments *interface_)
{
  g_object_set (G_OBJECT (object), "documents", interface_, NULL);
}

/**
 * goa_object_skeleton_set_exchange:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (allow-none): A #GoaExchange or %NULL to clear the interface.
 *
 * Sets the #GoaExchange instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link> on @object.
 *
 * Since: 3.6.0
 */
void goa_object_skeleton_set_exchange (GoaObjectSkeleton *object, GoaExchange *interface_)
{
  g_object_set (G_OBJECT (object), "exchange", interface_, NULL);
}

/**
 * goa_object_skeleton_set_ticketing:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (allow-none): A #GoaTicketing or %NULL to clear the interface.
 *
 * Sets the #GoaTicketing instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link> on @object.
 */
void goa_object_skeleton_set_ticketing (GoaObjectSkeleton *object, GoaTicketing *interface_)
{
  g_object_set (G_OBJECT (object), "ticketing", interface_, NULL);
}


/* ------------------------------------------------------------------------
 * Code for ObjectManager client
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaObjectManagerClient
 * @title: GoaObjectManagerClient
 * @short_description: Generated GDBusObjectManagerClient type
 *
 * This section contains a #GDBusObjectManagerClient that uses goa_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc.
 */

/**
 * GoaObjectManagerClient:
 *
 * The #GoaObjectManagerClient structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaObjectManagerClientClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaObjectManagerClient.
 */

G_DEFINE_TYPE (GoaObjectManagerClient, goa_object_manager_client, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT);

static void
goa_object_manager_client_init (GoaObjectManagerClient *manager)
{
}

static void
goa_object_manager_client_class_init (GoaObjectManagerClientClass *klass)
{
}

/**
 * goa_object_manager_client_get_proxy_type:
 * @manager: A #GDBusObjectManagerClient.
 * @object_path: The object path of the remote object (unused).
 * @interface_name: (allow-none): Interface name of the remote object or %NULL to get the object proxy #GType.
 * @user_data: User data (unused).
 *
 * A #GDBusProxyTypeFunc that maps @interface_name to the generated #GDBusObjectProxy<!-- -->- and #GDBusProxy<!-- -->-derived types.
 *
 * Returns: A #GDBusProxy<!-- -->-derived #GType if @interface_name is not %NULL, otherwise the #GType for #GoaObjectProxy.
 */
GType
goa_object_manager_client_get_proxy_type (GDBusObjectManagerClient *manager, const gchar *object_path, const gchar *interface_name, gpointer user_data)
{
  static gsize once_init_value = 0;
  static GHashTable *lookup_hash;
  GType ret;

  if (interface_name == NULL)
    return GOA_TYPE_OBJECT_PROXY;
  if (g_once_init_enter (&once_init_value))
    {
      lookup_hash = g_hash_table_new (g_str_hash, g_str_equal);
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Account", GSIZE_TO_POINTER (GOA_TYPE_ACCOUNT_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.OAuth2Based", GSIZE_TO_POINTER (GOA_TYPE_OAUTH2_BASED_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.OAuthBased", GSIZE_TO_POINTER (GOA_TYPE_OAUTH_BASED_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.PasswordBased", GSIZE_TO_POINTER (GOA_TYPE_PASSWORD_BASED_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Manager", GSIZE_TO_POINTER (GOA_TYPE_MANAGER_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Mail", GSIZE_TO_POINTER (GOA_TYPE_MAIL_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Calendar", GSIZE_TO_POINTER (GOA_TYPE_CALENDAR_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Contacts", GSIZE_TO_POINTER (GOA_TYPE_CONTACTS_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Chat", GSIZE_TO_POINTER (GOA_TYPE_CHAT_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Documents", GSIZE_TO_POINTER (GOA_TYPE_DOCUMENTS_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Exchange", GSIZE_TO_POINTER (GOA_TYPE_EXCHANGE_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Ticketing", GSIZE_TO_POINTER (GOA_TYPE_TICKETING_PROXY));
      g_once_init_leave (&once_init_value, 1);
    }
  ret = (GType) GPOINTER_TO_SIZE (g_hash_table_lookup (lookup_hash, interface_name));
  if (ret == (GType) 0)
    ret = G_TYPE_DBUS_PROXY;
  return ret;
}

/**
 * goa_object_manager_client_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates #GDBusObjectManagerClient using goa_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_object_manager_client_new_finish() to get the result of the operation.
 *
 * See goa_object_manager_client_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_object_manager_client_new (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data)
{
  g_async_initable_new_async (GOA_TYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", goa_object_manager_client_get_proxy_type, NULL);
}

/**
 * goa_object_manager_client_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_object_manager_client_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_object_manager_client_new().
 *
 * Returns: (transfer full) (type GoaObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
goa_object_manager_client_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}

/**
 * goa_object_manager_client_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates #GDBusObjectManagerClient using goa_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_object_manager_client_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
goa_object_manager_client_new_sync (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", goa_object_manager_client_get_proxy_type, NULL);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}


/**
 * goa_object_manager_client_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_object_manager_client_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call goa_object_manager_client_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_object_manager_client_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_object_manager_client_new_for_bus (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data)
{
  g_async_initable_new_async (GOA_TYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", goa_object_manager_client_get_proxy_type, NULL);
}

/**
 * goa_object_manager_client_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_object_manager_client_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_object_manager_client_new_for_bus().
 *
 * Returns: (transfer full) (type GoaObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
goa_object_manager_client_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}

/**
 * goa_object_manager_client_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_object_manager_client_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_object_manager_client_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
goa_object_manager_client_new_for_bus_sync (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", goa_object_manager_client_get_proxy_type, NULL);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}


